<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Paradoxe du Littoral - Laboratoire Interactif Finale</title>
    <style>
        /* --- STYLE THEME SOMBRE (CSS) --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e24;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0; /* Bleu cyan */
            --measure-color: #f72585; /* Rose néon */
            --coast-color: #4895ef; /* Bleu pour la côte */
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            margin: 0;
            line-height: 1.6;
        }

        h1 {
            margin: 30px 0; text-align: center; text-transform: uppercase;
            letter-spacing: 2px; color: var(--accent-color); font-size: 1.8em;
        }
        h2 {
            border-bottom: 1px solid #333; padding-bottom: 10px;
            margin-bottom: 20px; color: #fff; font-size: 1.3em;
        }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.95em; }

        .section-container {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        canvas {
            border-radius: 8px;
            background-color: #0a0a0f;
            width: 100%;
            height: auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            margin-bottom: 15px;
            display: block;
        }

        .controls {
            background-color: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 8px;
        }

        .slider-header {
            display: flex; justify-content: space-between; margin-bottom: 10px;
            font-weight: bold; color: var(--accent-color); font-size: 0.9em;
        }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--accent-color); margin-bottom: 15px;
        }

        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
        }
        .stats.single { grid-template-columns: 1fr; }

        .stat-box {
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;
            text-align: center; border: 1px solid #444;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        .stat-value { font-size: 1.2em; font-weight: bold; color: #fff; }
        .stat-value.highlight-pink { color: var(--measure-color); }
        .stat-value.highlight-blue { color: var(--accent-color); }
        
        .stat-label { font-size: 0.7em; color: #777; text-transform: uppercase; margin-top: 5px; }

        .button-area {
            margin-top: 15px;
            text-align: center;
        }

        button {
            background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);
            padding: 10px 20px; border-radius: 4px; cursor: pointer; transition: 0.3s; width: 100%; font-weight: bold;
        }
        button:hover { background: var(--accent-color); color: #000; }

        @media (min-width: 600px) {
            body { padding: 30px; }
            .section-container { padding: 30px; }
            h1 { font-size: 2.2em; }
            .stat-value { font-size: 1.5em; }
            button { width: auto; }
        }

    </style>
</head>
<body>

    <h1>Laboratoire du Paradoxe du Littoral</h1>

    <div class="section-container">
        <h2>1. La Transformation : Le Segment de Koch</h2>
        <p>Chaque segment est divisé en trois, et le tiers central est remplacé par un triangle pointant vers l'extérieur. Augmentez les itérations pour voir la courbe se fracturer et sa longueur augmenter.</p>
        
        <canvas id="segmentCanvas" width="800" height="350"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="segIterVal">0</span>
            </div>
            <input type="range" id="segmentIterations" min="0" max="5" value="0" step="1">
            
            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="segCountDisplay">1</div>
                    <div class="stat-label">Nombre de Segments totaux</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>2. L'Infini Borné : La Construction en Couches</h2>
        <p>Voici la construction du flocon étape par étape. Chaque nouvelle itération ajoute une série de triangles sur les côtés existants. Les nouvelles formes sont affichées dans une couleur plus claire.</p>
        
        <canvas id="layeredCanvas" width="600" height="600"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Étape</label>
                <span id="layeredIterVal">0</span>
            </div>
            <input type="range" id="layeredIterations" min="0" max="4" value="0" step="1">

            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="layeredStats">Triangle Initial</div>
                    <div class="stat-label">Description</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>3. La Simulation : L'Île Aléatoire</h2>
        <p>Utilisez le curseur pour changer la taille de votre "règle" (le pas de mesure &epsilon;). Observez la courbe rouge (votre mesure) se détacher de la côte bleue (le réel) quand la règle est trop grande.</p>
        
        <canvas id="islandCanvas" width="600" height="450"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="islandRulerValHeader">80</span> px</span>
            </div>
            <input type="range" id="islandRuler" min="5" max="150" value="80" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="islandLengthDisplay">0 px</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="islandEpsilonDisplay">80 px</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
            <div class="button-area">
                <button id="newIslandBtn">Générer une nouvelle île</button>
            </div>
        </div>
    </div>


     <div class="section-container">
        <h2>4. Le Cas Réel : La Grande-Bretagne</h2>
        <p>Le paradoxe appliqué à une vraie carte. Plus la règle est petite, plus elle entre dans les fjords et les baies, augmentant considérablement le résultat final.</p>
        
        <canvas id="gbCanvas" width="600" height="650"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="gbRulerValHeader">100</span> km (approx)</span>
            </div>
            <input type="range" id="gbRuler" min="15" max="180" value="100" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="gbLengthDisplay">0 km</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="gbEpsilonDisplay">100 km</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        /* =========================================
           FONCTIONS UTILITAIRES
           ========================================= */
        function dist(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        /* Fonction qui calcule les points d'un flocon de Koch (Outline) */
        function getKochPointsOutline(p1, p2, iterations) {
            if (iterations === 0) return [p1, p2];

            const vx = p2.x - p1.x;
            const vy = p2.y - p1.y;
            
            const pA = {x: p1.x + vx/3, y: p1.y + vy/3};
            const pB = {x: p1.x + 2*vx/3, y: p1.y + 2*vy/3};
            
            // Rotation +60 deg pour sortir (Si tracé CCW)
            const cos60 = 0.5;
            const sin60 = Math.sqrt(3)/2; 
            
            // Vecteur pA -> pB
            const vABx = pB.x - pA.x;
            const vABy = pB.y - pA.y;

            // Rotation
            const rotX = vABx * cos60 - vABy * sin60;
            const rotY = vABx * sin60 + vABy * cos60;

            const pTip = { x: pA.x + rotX, y: pA.y + rotY };

            const seg1 = getKochPointsOutline(p1, pA, iterations - 1);
            const seg2 = getKochPointsOutline(pA, pTip, iterations - 1);
            const seg3 = getKochPointsOutline(pTip, pB, iterations - 1);
            const seg4 = getKochPointsOutline(pB, p2, iterations - 1);

            return [...seg1, ...seg2.slice(1), ...seg3.slice(1), ...seg4.slice(1)];
        }


        /* =========================================
           1. LE SEGMENT DE KOCH (Ligne Simple)
           ========================================= */
        const sCanvas = document.getElementById('segmentCanvas');
        const sCtx = sCanvas.getContext('2d');
        const sSlider = document.getElementById('segmentIterations');
        
        function drawSegment() {
            const iter = parseInt(sSlider.value);
            document.getElementById('segIterVal').textContent = iter;
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
            
            const w = sCanvas.width;
            const h = sCanvas.height;
            // On inverse les points start/end pour que la "gauche" (Left) soit vers le haut
            // Sinon le +60deg pointe vers le bas.
            // Start a gauche, End a droite.
            const start = {x: w * 0.1, y: h * 0.75}; 
            const end = {x: w * 0.9, y: h * 0.75};
            
            // Pour un segment seul, on triche un peu sur la rotation ou on prend la fonction Outline
            // Avec ma fonction Outline +60, sur un segment gauche->droite, ça monte (car Y inversé, +angle = CW visuel ? Non)
            // Verifions visuellement :
            // HTML Canvas Y est vers le bas.
            // Vecteur (1,0). Rot +60 => (0.5, 0.866). Y positif = BAS.
            // Donc sur le canvas, +60 fait pointer vers le BAS.
            // Pour pointer vers le HAUT, il faut -60.
            
            // Je fais une version locale pour le segment seul qui pointe vers le haut
            function getSegPointsUp(p1, p2, n) {
                if (n === 0) return [p1, p2];
                const vx = p2.x - p1.x, vy = p2.y - p1.y;
                const pA = {x: p1.x + vx/3, y: p1.y + vy/3};
                const pB = {x: p1.x + 2*vx/3, y: p1.y + 2*vy/3};
                
                // Rotation -60 deg (vers le haut)
                const c = 0.5, s = -Math.sqrt(3)/2;
                const vBaseX = pB.x - pA.x, vBaseY = pB.y - pA.y;
                const tip = {
                    x: pA.x + (vBaseX * c - vBaseY * s),
                    y: pA.y + (vBaseX * s + vBaseY * c)
                };
                return [...getSegPointsUp(p1, pA, n-1), ...getSegPointsUp(pA, tip, n-1), ...getSegPointsUp(tip, pB, n-1), ...getSegPointsUp(pB, p2, n-1)];
            }

            const points = getSegPointsUp(start, end, iter);

            sCtx.beginPath();
            sCtx.strokeStyle = "#4cc9f0";
            sCtx.lineWidth = 2;
            sCtx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) sCtx.lineTo(points[i].x, points[i].y);
            sCtx.stroke();

            const numSeg = Math.pow(4, iter);
            document.getElementById('segCountDisplay').textContent = new Intl.NumberFormat().format(numSeg);
        }
        sSlider.addEventListener('input', drawSegment);
        drawSegment();


        /* =========================================
           2. CONSTRUCTION EN COUCHES (VISUEL REMPLI)
           ========================================= */
        const lCanvas = document.getElementById('layeredCanvas');
        const lCtx = lCanvas.getContext('2d');
        const lSlider = document.getElementById('layeredIterations');
        const lStats = document.getElementById('layeredStats');

        function drawLayered() {
            const maxIter = parseInt(lSlider.value);
            document.getElementById('layeredIterVal').textContent = maxIter;
            lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);

            const w = lCanvas.width;
            const h = lCanvas.height;
            const size = Math.min(w, h) * 0.55; 
            const heightTri = size * Math.sqrt(3)/2;
            const cx = w / 2;
            const cy = h / 2 + heightTri / 6; 

            // Triangle initial (Pointe en BAS pour que les ajouts aillent vers le HAUT/EXTERIEUR)
            // Définition en sens anti-horaire (CCW) : p1(HautD) -> p2(HautG) -> p3(Bas) ?
            // On veut le triangle gris de base "pointe en haut".
            // Donc p1(BasG), p2(BasD), p3(Haut).
            
            const p1 = {x: cx - size/2, y: cy + heightTri/3}; // Bas Gauche
            const p2 = {x: cx + size/2, y: cy + heightTri/3}; // Bas Droite
            const p3 = {x: cx, y: cy - 2*heightTri/3};       // Haut Pointe

            // Liste initiale des segments
            // Si on parcourt p1->p2->p3->p1 (CCW), l'intérieur est à gauche.
            // L'extérieur est à Droite.
            // Dans le Canvas (Y vers bas), Rotation Droite = +Angle.
            // Vérif: p1->p2 est horizontal droit (1,0). Rot +60 => (0.5, 0.866) => Bas.
            // Oups. Si le triangle est pointe en haut, le segment p1->p2 est en bas.
            // L'extérieur est en BAS. Donc +60 est correct.
            
            let segments = [
                {a: p1, b: p2},
                {a: p2, b: p3},
                {a: p3, b: p1}
            ];

            // 1. Dessiner la base (Iter 0)
            lCtx.fillStyle = "#2c3e50"; // Couleur sombre de base (Gris/Bleu foncé)
            lCtx.beginPath();
            lCtx.moveTo(p1.x, p1.y);
            lCtx.lineTo(p2.x, p2.y);
            lCtx.lineTo(p3.x, p3.y);
            lCtx.closePath();
            lCtx.fill();
            lCtx.strokeStyle = "#4cc9f0";
            lCtx.lineWidth = 1;
            lCtx.stroke();

            // Boucle pour chaque itération demandée
            // On dessine les triangles "par dessus"
            for (let i = 0; i < maxIter; i++) {
                let nextSegments = [];
                
                // Couleur différente pour chaque couche
                // On éclaircit la couleur à chaque étape pour l'effet "Neige"
                // Etape 0: Base foncée. Etape 1: plus clair...
                const lightness = 40 + (i * 15);
                lCtx.fillStyle = `hsl(200, 70%, ${lightness}%)`; 
                
                lCtx.beginPath(); // On commence un path pour tous les triangles de cette étape
                
                for (let seg of segments) {
                    const u = seg.a;
                    const v = seg.b;
                    
                    const vx = v.x - u.x;
                    const vy = v.y - u.y;

                    const pA = {x: u.x + vx/3, y: u.y + vy/3};
                    const pB = {x: u.x + 2*vx/3, y: u.y + 2*vy/3};

                    // Calcul de la pointe du triangle équilatéral sortant
                    // Rotation +60 deg (car parcours CCW et Canvas Y inversé)
                    const c = 0.5;
                    const s = Math.sqrt(3)/2; // +sin60
                    
                    const tipX = pA.x + (pB.x - pA.x)*c - (pB.y - pA.y)*s;
                    const tipY = pA.y + (pB.x - pA.x)*s + (pB.y - pA.y)*c;
                    const pTip = {x: tipX, y: tipY};

                    // Ajouter ce triangle au chemin de dessin
                    lCtx.moveTo(pA.x, pA.y);
                    lCtx.lineTo(pB.x, pB.y);
                    lCtx.lineTo(pTip.x, pTip.y);
                    lCtx.lineTo(pA.x, pA.y); // Fermer

                    // Préparer les segments pour la prochaine itération
                    // Le segment u->v devient 4 segments : u->pA, pA->pTip, pTip->pB, pB->v
                    nextSegments.push({a: u, b: pA});
                    nextSegments.push({a: pA, b: pTip});
                    nextSegments.push({a: pTip, b: pB});
                    nextSegments.push({a: pB, b: v});
                }
                
                lCtx.fill();
                lCtx.stroke(); // Garder un contour pour la netteté
                
                segments = nextSegments;
            }

            let desc = "";
            if(maxIter === 0) desc = "Triangle Initial";
            else if(maxIter === 1) desc = "Étoile de David (6 branches)";
            else desc = `Itération ${maxIter} : ${segments.length/4} pointes ajoutées`;
            lStats.textContent = desc;
        }
        lSlider.addEventListener('input', drawLayered);
        drawLayered();


        /* =========================================
           3. L'ÎLE ALÉATOIRE & MESURE
           ========================================= */
        const iCanvas = document.getElementById('islandCanvas');
        const iCtx = iCanvas.getContext('2d');
        const iSlider = document.getElementById('islandRuler');
        let islandPoints = [];

        function generateBetterIsland() {
            islandPoints = [];
            const w = iCanvas.width;
            const h = iCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const baseRadius = Math.min(w, h) * 0.25;
            const noiseAmp = baseRadius * 0.6; 
            const numPoints = 1200; 
            const seeds = [Math.random(), Math.random(), Math.random(), Math.random()];
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (Math.PI * 2 * i) / numPoints;
                let noise = Math.sin(angle * 3 + seeds[0]) * noiseAmp +
                            Math.sin(angle * 10 + seeds[1]) * (noiseAmp*0.5) +
                            Math.sin(angle * 25 + seeds[2]) * (noiseAmp*0.25) +
                            Math.sin(angle * 60 + seeds[3]) * (noiseAmp*0.1);

                const r = baseRadius + noise;
                islandPoints.push({x: centerX + r * Math.cos(angle), y: centerY + r * Math.sin(angle)});
            }
        }

        function measurePoly(points, rulerLen, ctx, w, h, scale=1, unit="px", filled=false) {
            if(points.length < 2) return;
            ctx.clearRect(0,0,w,h);

            ctx.beginPath();
            if(filled) ctx.fillStyle = "#1e2a38";
            ctx.strokeStyle = "#4895ef"; 
            ctx.lineWidth = 1.5;
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            if(filled) ctx.fill();
            ctx.stroke();

            let mPoints = [points[0]];
            let currIdx = 0;
            let totalDist = 0;
            while(true) {
                let found = false;
                for(let i = currIdx + 1; i < points.length; i++) {
                    let d = dist(points[currIdx], points[i]);
                    if (d >= rulerLen) {
                        totalDist += d;
                        mPoints.push(points[i]);
                        currIdx = i;
                        found = true;
                        break;
                    }
                }
                if(!found) {
                    let dFinal = dist(points[currIdx], points[0]);
                    if(dFinal >= rulerLen * 0.5 || mPoints.length > 3) { 
                        totalDist += dFinal;
                        mPoints.push(points[0]);
                    }
                    break;
                }
            }

            ctx.beginPath();
            ctx.strokeStyle = "#f72585";
            ctx.lineWidth = 2.5;
            ctx.moveTo(mPoints[0].x, mPoints[0].y);
            for(let p of mPoints) ctx.lineTo(p.x, p.y);
            ctx.stroke();
             
            for(let p of mPoints) {
                ctx.beginPath(); ctx.fillStyle = "#f72585";
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            }

            return Math.round(totalDist * scale) + " " + unit;
        }

        function runIslandMeasurement() {
            const val = parseInt(iSlider.value);
            document.getElementById('islandRulerValHeader').textContent = val;
            document.getElementById('islandEpsilonDisplay').textContent = val + " px";

            const res = measurePoly(islandPoints, val, iCtx, iCanvas.width, iCanvas.height);
            document.getElementById('islandLengthDisplay').textContent = res;
        }

        iSlider.addEventListener('input', runIslandMeasurement);
        document.getElementById('newIslandBtn').addEventListener('click', () => {
            generateBetterIsland();
            runIslandMeasurement();
        });
        generateBetterIsland();
        runIslandMeasurement();


        /* =========================================
           4. LA GRANDE BRETAGNE
           ========================================= */
        const gCanvas = document.getElementById('gbCanvas');
        const gCtx = gCanvas.getContext('2d');
        const gSlider = document.getElementById('gbRuler');

        const gbShapeNormalized = [
            {x:30,y:85},{x:40,y:87},{x:50,y:85},{x:60,y:82},{x:75,y:80},{x:85,y:78}, 
            {x:88,y:75},{x:90,y:70},{x:88,y:65},{x:85,y:62}, 
            {x:82,y:55},{x:80,y:50},{x:78,y:40},{x:75,y:30}, 
            {x:70,y:20},{x:65,y:10},{x:55,y:5},{x:45,y:5},{x:40,y:10}, 
            {x:35,y:20},{x:30,y:30},{x:35,y:35}, 
            {x:30,y:40},{x:35,y:45},{x:40,y:48}, 
            {x:35,y:50},{x:30,y:55},{x:25,y:60},{x:20,y:58},{x:15,y:62},{x:20,y:68}, 
            {x:35,y:65},{x:40,y:70},{x:35,y:75},{x:30,y:80} 
        ];
        let gbPoints = [];

        function generateGBPoints() {
            gbPoints = [];
            const w = gCanvas.width; const h = gCanvas.height;
            const intendedWidth = w * 0.65;
            const scaleFactor = intendedWidth / 75;
            const offsetX = w/2 - (55 * scaleFactor);
            const offsetY = h/2 - (45 * scaleFactor);

            for(let i=0; i<gbShapeNormalized.length; i++) {
                const p1 = gbShapeNormalized[i];
                const p2 = gbShapeNormalized[(i+1)%gbShapeNormalized.length];
                const steps = 20; 
                for(let j=0; j<steps; j++) {
                    const t = j/steps;
                    gbPoints.push({
                        x: (p1.x + (p2.x - p1.x)*t) * scaleFactor + offsetX, 
                        y: (p1.y + (p2.y - p1.y)*t) * scaleFactor + offsetY
                    });
                }
            }
        }

        function runGBMeasurement() {
            if(gbPoints.length === 0) generateGBPoints();
            const rulerPx = parseInt(gSlider.value);
            
            document.getElementById('gbRulerValHeader').textContent = rulerPx;
            document.getElementById('gbEpsilonDisplay').textContent = rulerPx + " km";
            
            const kmScaleFactor = 2000 / gCanvas.width; 
            const res = measurePoly(gbPoints, rulerPx, gCtx, gCanvas.width, gCanvas.height, kmScaleFactor, "km", true);
            document.getElementById('gbLengthDisplay').textContent = res;
        }

        gSlider.addEventListener('input', runGBMeasurement);
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                drawSegment(); drawLayered();
                generateBetterIsland(); runIslandMeasurement();
                generateGBPoints(); runGBMeasurement();
            }, 250);
        });

        setTimeout(() => { generateGBPoints(); runGBMeasurement(); }, 200);

    </script>
</body>
</html>
