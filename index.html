<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Paradoxe du Littoral - Laboratoire Interactif V4</title>
    <style>
        /* --- STYLE THEME SOMBRE (CSS) --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e24;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0; /* Bleu cyan */
            --measure-color: #f72585; /* Rose néon */
            --coast-color: #4895ef; /* Bleu pour la côte */
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            margin: 0;
            line-height: 1.6;
        }

        h1 {
            margin: 30px 0; text-align: center; text-transform: uppercase;
            letter-spacing: 2px; color: var(--accent-color); font-size: 1.8em;
        }
        h2 {
            border-bottom: 1px solid #333; padding-bottom: 10px;
            margin-bottom: 20px; color: #fff; font-size: 1.3em;
        }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.95em; }

        .section-container {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        canvas {
            border-radius: 8px;
            background-color: #0a0a0f;
            width: 100%;
            height: auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            margin-bottom: 15px;
            display: block;
        }

        .controls {
            background-color: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 8px;
        }

        .slider-header {
            display: flex; justify-content: space-between; margin-bottom: 10px;
            font-weight: bold; color: var(--accent-color); font-size: 0.9em;
        }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--accent-color); margin-bottom: 15px;
        }

        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
        }
        .stats.single { grid-template-columns: 1fr; }

        .stat-box {
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;
            text-align: center; border: 1px solid #444;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        .stat-value { font-size: 1.2em; font-weight: bold; color: #fff; }
        .stat-value.highlight-pink { color: var(--measure-color); }
        .stat-value.highlight-blue { color: var(--accent-color); }
        
        .stat-label { font-size: 0.7em; color: #777; text-transform: uppercase; margin-top: 5px; }

        /* Nouveau conteneur pour le bouton sous les stats */
        .button-area {
            margin-top: 15px;
            text-align: center;
        }

        button {
            background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);
            padding: 10px 20px; border-radius: 4px; cursor: pointer; transition: 0.3s; width: 100%; font-weight: bold;
        }
        button:hover { background: var(--accent-color); color: #000; }

        /* --- MEDIA QUERIES POUR MOBILE --- */
        @media (min-width: 600px) {
            body { padding: 30px; }
            .section-container { padding: 30px; }
            h1 { font-size: 2.2em; }
            .stat-value { font-size: 1.5em; }
            button { width: auto; }
        }

    </style>
</head>
<body>

    <h1>Laboratoire du Paradoxe du Littoral</h1>

    <div class="section-container">
        <h2>1. La Transformation : Le Segment de Koch</h2>
        <p>Chaque segment est divisé en trois, et le tiers central est remplacé par un triangle pointant vers l'extérieur. Augmentez les itérations pour voir la courbe se fracturer et sa longueur augmenter.</p>
        
        <canvas id="segmentCanvas" width="800" height="350"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="segIterVal">0</span>
            </div>
            <input type="range" id="segmentIterations" min="0" max="5" value="0" step="1">
            
            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="segCountDisplay">1</div>
                    <div class="stat-label">Nombre de Segments totaux</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>2. L'Infini Borné : La Construction de l'Étoile</h2>
        <p>Cette simulation montre les premières étapes de la construction d'une fractale en forme d'étoile, similaire à celle de l'image fournie.</p>
        
        <canvas id="customFractalCanvas" width="600" height="600"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Étape</label>
                <span id="customIterVal">0</span>
            </div>
            <input type="range" id="customIterations" min="0" max="2" value="0" step="1">

            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="customStats">Triangle Initial</div>
                    <div class="stat-label">Description</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>3. La Simulation : L'Île Aléatoire</h2>
        <p>Utilisez le curseur pour changer la taille de votre "règle" (le pas de mesure &epsilon;). Observez la courbe rouge (votre mesure) se détacher de la côte bleue (le réel) quand la règle est trop grande.</p>
        
        <canvas id="islandCanvas" width="600" height="450"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="islandRulerValHeader">80</span> px</span>
            </div>
            <input type="range" id="islandRuler" min="5" max="150" value="80" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="islandLengthDisplay">0 px</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="islandEpsilonDisplay">80 px</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
            <div class="button-area">
                <button id="newIslandBtn">Générer une nouvelle île</button>
            </div>
        </div>
    </div>


     <div class="section-container">
        <h2>4. Le Cas Réel : La Grande-Bretagne</h2>
        <p>Le paradoxe appliqué à une vraie carte. Plus la règle est petite, plus elle entre dans les fjords et les baies, augmentant considérablement le résultat final.</p>
        
        <canvas id="gbCanvas" width="600" height="650"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="gbRulerValHeader">100</span> km (approx)</span>
            </div>
            <input type="range" id="gbRuler" min="15" max="180" value="100" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="gbLengthDisplay">0 km</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="gbEpsilonDisplay">100 km</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        /* =========================================
           FONCTIONS UTILITAIRES (MATHS)
           ========================================= */
        function dist(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        /* CORRECTION MAJEURE ICI : 
           Fonction récursive de Koch avec rotation mathématique correcte
           pour pointer vers l'EXTÉRIEUR (rotation de -60° du vecteur directeur).
        */
        function getKochPoints(p1, p2, iterations) {
            if (iterations === 0) return [p1, p2];

            // Vecteur P1 -> P2
            const vx = p2.x - p1.x;
            const vy = p2.y - p1.y;
            
            // Les 3 points intermédiaires sur le segment
            const pA = {x: p1.x + vx/3, y: p1.y + vy/3};
            const pB = {x: p1.x + 2*vx/3, y: p1.y + 2*vy/3};
            
            // Calcul de la pointe : Rotation du vecteur pA->pB de -60 degrés
            // cos(-60) = 0.5, sin(-60) = -sqrt(3)/2
            const cosN60 = 0.5;
            const sinN60 = -Math.sqrt(3)/2;
            
            // Vecteur pA -> pB
            const vABx = pB.x - pA.x;
            const vABy = pB.y - pA.y;

            // Application de la matrice de rotation
            const rotX = vABx * cosN60 - vABy * sinN60;
            const rotY = vABx * sinN60 + vABy * cosN60;

            const pTip = {
                x: pA.x + rotX,
                y: pA.y + rotY
            };

            // Récursion
            const seg1 = getKochPoints(p1, pA, iterations - 1);
            const seg2 = getKochPoints(pA, pTip, iterations - 1);
            const seg3 = getKochPoints(pTip, pB, iterations - 1);
            const seg4 = getKochPoints(pB, p2, iterations - 1);

            return [...seg1, ...seg2.slice(1), ...seg3.slice(1), ...seg4.slice(1)];
        }


        /* =========================================
           1. LE SEGMENT DE KOCH (Simple Ligne)
           ========================================= */
        const sCanvas = document.getElementById('segmentCanvas');
        const sCtx = sCanvas.getContext('2d');
        const sSlider = document.getElementById('segmentIterations');
        
        function drawSegment() {
            const iter = parseInt(sSlider.value);
            document.getElementById('segIterVal').textContent = iter;
            
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
            
            const w = sCanvas.width;
            const h = sCanvas.height;
            // Ligne placée plus bas pour laisser la place à la pointe de monter
            const start = {x: w * 0.1, y: h * 0.75}; 
            const end = {x: w * 0.9, y: h * 0.75};
            
            const points = getKochPoints(start, end, iter);

            sCtx.beginPath();
            sCtx.strokeStyle = "#4cc9f0";
            sCtx.lineWidth = 2;
            sCtx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) sCtx.lineTo(points[i].x, points[i].y);
            sCtx.stroke();

            const numSeg = Math.pow(4, iter);
            document.getElementById('segCountDisplay').textContent = new Intl.NumberFormat().format(numSeg);
        }
        sSlider.addEventListener('input', drawSegment);
        drawSegment();


        /* =========================================
           2. CONSTRUCTION DE L'ÉTOILE (Image fournie)
           ========================================= */
        const cCanvas = document.getElementById('customFractalCanvas');
        const cCtx = cCanvas.getContext('2d');
        const cSlider = document.getElementById('customIterations');
        const cStats = document.getElementById('customStats');

        function drawTriangle(ctx, x, y, size, rotation, color) {
            ctx.beginPath();
            ctx.moveTo(x + size * Math.cos(rotation), y + size * Math.sin(rotation));
            ctx.lineTo(x + size * Math.cos(rotation + 2 * Math.PI / 3), y + size * Math.sin(rotation + 2 * Math.PI / 3));
            ctx.lineTo(x + size * Math.cos(rotation + 4 * Math.PI / 3), y + size * Math.sin(rotation + 4 * Math.PI / 3));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        function drawCustomFractal() {
            const iter = parseInt(cSlider.value);
            document.getElementById('customIterVal').textContent = iter;
            cCtx.clearRect(0, 0, cCanvas.width, cCanvas.height);

            const w = cCanvas.width;
            const h = cCanvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const size1 = Math.min(w, h) * 0.4;
            const size2 = size1 * 1.2; // Second triangle is slightly larger
            const size3 = size1 / 3; // Smaller triangles

            let description = "";

            if (iter >= 0) {
                // Étape 0: Premier triangle gris clair, pointe en haut
                drawTriangle(cCtx, cx, cy + size1 / 6, size1, -Math.PI / 2, '#999999');
                description = "Triangle Initial";
            }

            if (iter >= 1) {
                // Étape 1: Deuxième triangle gris foncé, pointe en bas
                drawTriangle(cCtx, cx, cy - size2 / 6, size2, Math.PI / 2, '#555555');
                description = "Étoile à Six Branches";
            }

            if (iter >= 2) {
                // Étape 2: Petits triangles gris foncé sur les pointes
                const angles = [-Math.PI / 2, -Math.PI / 6, Math.PI / 6, Math.PI / 2, 5 * Math.PI / 6, 7 * Math.PI / 6];
                const distances = [size1, size2, size1, size2, size1, size2];
                
                for (let i = 0; i < 6; i++) {
                    const angle = angles[i];
                    // Adjust distance and center for the small triangles to sit on the tips
                    const dist = distances[i];
                    // The small triangles are centered on the vertices of the previous star
                    const tx = cx + dist * Math.cos(angle);
                    const ty = (cy + (i % 2 === 0 ? size1 / 6 : -size2 / 6)) + dist * Math.sin(angle);
                    // Rotation is opposite to the vertex they are on
                    drawTriangle(cCtx, tx, ty, size3, angle + Math.PI, '#555555');
                }
                description = "Fractale en Étoile";
            }
            cStats.textContent = description;
        }
        cSlider.addEventListener('input', drawCustomFractal);
        drawCustomFractal();


        /* =========================================
           3. L'ÎLE ALÉATOIRE & MESURE
           ========================================= */
        const iCanvas = document.getElementById('islandCanvas');
        const iCtx = iCanvas.getContext('2d');
        const iSlider = document.getElementById('islandRuler');
        let islandPoints = [];

        function generateBetterIsland() {
            islandPoints = [];
            const w = iCanvas.width;
            const h = iCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const baseRadius = Math.min(w, h) * 0.25;
            const noiseAmp = baseRadius * 0.6; 
            const numPoints = 1200; 
            
            const seeds = [Math.random(), Math.random(), Math.random(), Math.random()];
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (Math.PI * 2 * i) / numPoints;
                let noise = Math.sin(angle * 3 + seeds[0]) * noiseAmp +
                            Math.sin(angle * 10 + seeds[1]) * (noiseAmp*0.5) +
                            Math.sin(angle * 25 + seeds[2]) * (noiseAmp*0.25) +
                            Math.sin(angle * 60 + seeds[3]) * (noiseAmp*0.1);

                const r = baseRadius + noise;
                islandPoints.push({x: centerX + r * Math.cos(angle), y: centerY + r * Math.sin(angle)});
            }
        }

        function measurePoly(points, rulerLen, ctx, w, h, scale=1, unit="px", filled=false) {
            if(points.length < 2) return;
            ctx.clearRect(0,0,w,h);

            // Dessin forme réelle
            ctx.beginPath();
            if(filled) ctx.fillStyle = "#1e2a38";
            ctx.strokeStyle = "#4895ef"; 
            ctx.lineWidth = 1.5;
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            if(filled) ctx.fill();
            ctx.stroke();

            // Mesure
            let mPoints = [points[0]];
            let currIdx = 0;
            let totalDist = 0;
            while(true) {
                let found = false;
                for(let i = currIdx + 1; i < points.length; i++) {
                    let d = dist(points[currIdx], points[i]);
                    if (d >= rulerLen) {
                        totalDist += d;
                        mPoints.push(points[i]);
                        currIdx = i;
                        found = true;
                        break;
                    }
                }
                if(!found) {
                    let dFinal = dist(points[currIdx], points[0]);
                    if(dFinal >= rulerLen * 0.5 || mPoints.length > 3) { 
                        totalDist += dFinal;
                        mPoints.push(points[0]);
                    }
                    break;
                }
            }

            // Dessin mesure
            ctx.beginPath();
            ctx.strokeStyle = "#f72585";
            ctx.lineWidth = 2.5;
            ctx.moveTo(mPoints[0].x, mPoints[0].y);
            for(let p of mPoints) ctx.lineTo(p.x, p.y);
            ctx.stroke();
             
            for(let p of mPoints) {
                ctx.beginPath(); ctx.fillStyle = "#f72585";
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            }

            return Math.round(totalDist * scale) + " " + unit;
        }

        function runIslandMeasurement() {
            const val = parseInt(iSlider.value);
            // Mise à jour des deux affichages (header + boîte)
            document.getElementById('islandRulerValHeader').textContent = val;
            document.getElementById('islandEpsilonDisplay').textContent = val + " px";

            const res = measurePoly(islandPoints, val, iCtx, iCanvas.width, iCanvas.height);
            document.getElementById('islandLengthDisplay').textContent = res;
        }

        iSlider.addEventListener('input', runIslandMeasurement);
        document.getElementById('newIslandBtn').addEventListener('click', () => {
            generateBetterIsland();
            runIslandMeasurement();
        });
        generateBetterIsland();
        runIslandMeasurement();


        /* =========================================
           4. LA GRANDE BRETAGNE
           ========================================= */
        const gCanvas = document.getElementById('gbCanvas');
        const gCtx = gCanvas.getContext('2d');
        const gSlider = document.getElementById('gbRuler');

        const gbShapeNormalized = [
            {x:30,y:85},{x:40,y:87},{x:50,y:85},{x:60,y:82},{x:75,y:80},{x:85,y:78}, 
            {x:88,y:75},{x:90,y:70},{x:88,y:65},{x:85,y:62}, 
            {x:82,y:55},{x:80,y:50},{x:78,y:40},{x:75,y:30}, 
            {x:70,y:20},{x:65,y:10},{x:55,y:5},{x:45,y:5},{x:40,y:10}, 
            {x:35,y:20},{x:30,y:30},{x:35,y:35}, 
            {x:30,y:40},{x:35,y:45},{x:40,y:48}, 
            {x:35,y:50},{x:30,y:55},{x:25,y:60},{x:20,y:58},{x:15,y:62},{x:20,y:68}, 
            {x:35,y:65},{x:40,y:70},{x:35,y:75},{x:30,y:80} 
        ];
        let gbPoints = [];

        function generateGBPoints() {
            gbPoints = [];
            const w = gCanvas.width; const h = gCanvas.height;
            const intendedWidth = w * 0.65;
            const scaleFactor = intendedWidth / 75;
            const offsetX = w/2 - (55 * scaleFactor);
            const offsetY = h/2 - (45 * scaleFactor);

            for(let i=0; i<gbShapeNormalized.length; i++) {
                const p1 = gbShapeNormalized[i];
                const p2 = gbShapeNormalized[(i+1)%gbShapeNormalized.length];
                const steps = 20; 
                for(let j=0; j<steps; j++) {
                    const t = j/steps;
                    gbPoints.push({
                        x: (p1.x + (p2.x - p1.x)*t) * scaleFactor + offsetX, 
                        y: (p1.y + (p2.y - p1.y)*t) * scaleFactor + offsetY
                    });
                }
            }
        }

        function runGBMeasurement() {
            if(gbPoints.length === 0) generateGBPoints();
            const rulerPx = parseInt(gSlider.value);
            
            // Mise à jour des deux affichages (header + boîte)
            document.getElementById('gbRulerValHeader').textContent = rulerPx;
            document.getElementById('gbEpsilonDisplay').textContent = rulerPx + " km";
            
            const kmScaleFactor = 2000 / gCanvas.width; 
            const res = measurePoly(gbPoints, rulerPx, gCtx, gCanvas.width, gCanvas.height, kmScaleFactor, "km", true);
            document.getElementById('gbLengthDisplay').textContent = res;
        }

        gSlider.addEventListener('input', runGBMeasurement);
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                drawSegment(); drawCustomFractal();
                generateBetterIsland(); runIslandMeasurement();
                generateGBPoints(); runGBMeasurement();
            }, 250);
        });

        setTimeout(() => { generateGBPoints(); runGBMeasurement(); }, 200);

    </script>
</body>
</html>
