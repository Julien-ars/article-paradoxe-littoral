<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Paradoxe du Littoral - Laboratoire Interactif</title>
    <style>
        /* --- STYLE THEME SOMBRE (CSS) --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e24;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0; /* Bleu cyan */
            --measure-color: #f72585; /* Rose néon */
            --coast-color: #4895ef; /* Bleu pour la côte */
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px; /* Réduit pour mobile */
            margin: 0;
            line-height: 1.6;
        }

        h1 {
            margin: 30px 0; text-align: center; text-transform: uppercase;
            letter-spacing: 2px; color: var(--accent-color); font-size: 1.8em;
        }
        h2 {
            border-bottom: 1px solid #333; padding-bottom: 10px;
            margin-bottom: 20px; color: #fff; font-size: 1.3em;
        }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.95em; }

        .section-container {
            background: var(--container-bg);
            padding: 20px; /* Réduit pour mobile */
            border-radius: 16px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            border: 1px solid #333;
            box-sizing: border-box; /* Important pour que le padding ne dépasse pas */
        }

        canvas {
            border-radius: 8px;
            background-color: #0a0a0f;
            width: 100%; /* Prend toute la largeur du conteneur */
            height: auto; /* Hauteur automatique pour garder le ratio */
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            margin-bottom: 15px;
            display: block; /* Évite des marges fantômes */
        }

        .controls {
            background-color: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 8px;
        }

        .slider-header {
            display: flex; justify-content: space-between; margin-bottom: 10px;
            font-weight: bold; color: var(--accent-color); font-size: 0.9em;
        }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--accent-color); margin-bottom: 15px;
        }

        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
        }
        
        /* Pour le premier cas où il n'y a qu'une seule stat */
        .stats.single { grid-template-columns: 1fr; }

        .stat-box {
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;
            text-align: center; border: 1px solid #444;
        }

        .stat-value { font-size: 1.2em; font-weight: bold; color: #fff; }
        .stat-value.highlight { color: var(--measure-color); }
        .stat-label { font-size: 0.7em; color: #777; text-transform: uppercase; margin-top: 5px; }

        button {
            background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);
            padding: 8px 16px; border-radius: 4px; cursor: pointer; transition: 0.3s; width: 100%;
        }
        button:hover { background: var(--accent-color); color: #000; }

        /* --- MEDIA QUERIES POUR MOBILE --- */
        @media (min-width: 600px) {
            body { padding: 30px; }
            .section-container { padding: 30px; }
            h1 { font-size: 2.2em; }
            .stat-value { font-size: 1.5em; }
            button { width: auto; }
        }

    </style>
</head>
<body>

    <h1>Laboratoire du Paradoxe du Littoral</h1>

    <div class="section-container">
        <h2>1. La Transformation : Le Segment de Koch</h2>
        <p>Chaque segment est divisé en trois, et le tiers central est remplacé par un triangle pointant vers l'extérieur. Augmentez les itérations pour voir la courbe se fracturer et sa longueur augmenter.</p>
        
        <canvas id="segmentCanvas" width="800" height="300"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="segIterVal">0</span>
            </div>
            <input type="range" id="segmentIterations" min="0" max="6" value="0" step="1">
            
            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="segCountDisplay">1</div>
                    <div class="stat-label">Nombre de Segments totaux</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>2. L'Infini Borné : Le Flocon de Koch</h2>
        <p>En appliquant cette transformation sur les trois côtés d'un triangle, on obtient le Flocon. Notez que l'aire reste finie (le flocon tient dans l'écran), mais son périmètre augmente à chaque étape.</p>
        
        <canvas id="kochCanvas" width="600" height="550"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="kochIterVal">0</span>
            </div>
            <input type="range" id="kochIterations" min="0" max="5" value="0" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="kochSegmentsDisplay">3</div>
                    <div class="stat-label">Nombre de segments</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value highlight" id="kochLengthDisplay">100 u</div>
                    <div class="stat-label">Périmètre Théorique</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>3. La Simulation : L'Île Aléatoire</h2>
        <p>Utilisez le curseur pour changer la taille de votre "règle" (le pas de mesure &epsilon;). Observez la courbe rouge (votre mesure) se détacher de la côte bleue (le réel) quand la règle est trop grande.</p>
        
        <canvas id="islandCanvas" width="600" height="450"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="islandRulerVal">80</span> px</span>
            </div>
            <input type="range" id="islandRuler" min="5" max="150" value="80" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight" id="islandLengthDisplay">0 px</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box" style="display:flex; align-items:center; justify-content:center;">
                    <button id="newIslandBtn">Générer nouvelle île</button>
                </div>
            </div>
        </div>
    </div>


     <div class="section-container">
        <h2>4. Le Cas Réel : La Grande-Bretagne</h2>
        <p>Le paradoxe appliqué à une vraie carte. Plus la règle est petite, plus elle entre dans les fjords et les baies, augmentant considérablement le résultat final.</p>
        
        <canvas id="gbCanvas" width="600" height="650"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="gbRulerVal">100</span> km (approx)</span>
            </div>
            <input type="range" id="gbRuler" min="15" max="180" value="100" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight" id="gbLengthDisplay">0 km</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box" style="display:flex; flex-direction:column; justify-content:center; padding:5px;">
                    <div style="font-size:0.75em; color:#666; line-height:1.2;">Les données sont simplifiées pour la fluidité de l'animation dans le navigateur.</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        /* =========================================
           FONCTIONS UTILITAIRES (MATHS)
           ========================================= */
        function dist(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        /* Fonction récursive de Koch générique */
        function getKochPoints(p1, p2, iterations) {
            if (iterations === 0) return [p1, p2];

            const vX = p2.x - p1.x;
            const vY = p2.y - p1.y;
            
            // Les 3 points intermédiaires sur le segment
            const pA = {x: p1.x + vX/3, y: p1.y + vY/3};
            const pB = {x: p1.x + 2*vX/3, y: p1.y + 2*vY/3};
            
            // Calcul de la pointe (triangle équilatéral)
            const sin60 = Math.sqrt(3)/2;
            const cos60 = 0.5;
            
            // CORRECTION ICI : Inversion des signes pour pointer vers l'extérieur
            // Rotation de -60 degrés (ou +60 selon le repère, mais cela inverse le sens précédent)
            const pTip = {
                x: pA.x + (pB.x - pA.x) * cos60 + (pB.y - pA.y) * sin60,
                y: pA.y - (pB.x - pA.x) * sin60 + (pB.y - pA.y) * cos60
            };

            // Récursion
            const seg1 = getKochPoints(p1, pA, iterations - 1);
            const seg2 = getKochPoints(pA, pTip, iterations - 1);
            const seg3 = getKochPoints(pTip, pB, iterations - 1);
            const seg4 = getKochPoints(pB, p2, iterations - 1);

            // On fusionne en évitant les doublons de points de jonction
            return [...seg1, ...seg2.slice(1), ...seg3.slice(1), ...seg4.slice(1)];
        }


        /* =========================================
           1. LE SEGMENT DE KOCH (Simple Ligne)
           ========================================= */
        const sCanvas = document.getElementById('segmentCanvas');
        const sCtx = sCanvas.getContext('2d');
        const sSlider = document.getElementById('segmentIterations');
        
        function drawSegment() {
            const iter = parseInt(sSlider.value);
            document.getElementById('segIterVal').textContent = iter;
            
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
            
            // Définition dynamique de la ligne de base (responsive)
            const w = sCanvas.width;
            const h = sCanvas.height;
            // On place la ligne en bas (70% de la hauteur) pour laisser la place au triangle de monter
            const start = {x: w * 0.1, y: h * 0.7}; 
            const end = {x: w * 0.9, y: h * 0.7};
            
            const points = getKochPoints(start, end, iter);

            // Dessin
            sCtx.beginPath();
            sCtx.strokeStyle = "#4cc9f0";
            sCtx.lineWidth = 2;
            sCtx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) sCtx.lineTo(points[i].x, points[i].y);
            sCtx.stroke();

            // Stats (Nombre de segments seulement)
            const numSeg = Math.pow(4, iter);
            document.getElementById('segCountDisplay').textContent = new Intl.NumberFormat().format(numSeg);
        }
        sSlider.addEventListener('input', drawSegment);
        // On appelle la fonction au chargement
        drawSegment();


        /* =========================================
           2. LE FLOCON DE KOCH (Triangle complet)
           ========================================= */
        const kCanvas = document.getElementById('kochCanvas');
        const kCtx = kCanvas.getContext('2d');
        const kSlider = document.getElementById('kochIterations');
        
        function drawKoch() {
            const iter = parseInt(kSlider.value);
            document.getElementById('kochIterVal').textContent = iter;
            kCtx.clearRect(0,0, kCanvas.width, kCanvas.height);

            // Définition dynamique du triangle initial (responsive)
            const w = kCanvas.width;
            const h = kCanvas.height;
            // Taille du triangle par rapport à la plus petite dimension du canvas
            const size = Math.min(w, h) * 0.55; 
            const heightTri = size * Math.sqrt(3)/2;
            
            const cx = w / 2;
            // On centre verticalement le "bounding box" du flocon final, pas juste le triangle initial
            const cy = h / 2 + heightTri / 6; 

            const p1 = {x: cx - size/2, y: cy - heightTri/3}; // Haut Gauche (si inversé) -> Bas Gauche
            const p2 = {x: cx + size/2, y: cy - heightTri/3}; // Haut Droite -> Bas Droite
            const p3 = {x: cx, y: cy + 2*heightTri/3};     // Bas -> Haut Pointe

            // Comme j'ai inversé la fonction getKochPoints pour qu'elle pointe vers l'extérieur,
            // je dois définir mon triangle initial "à l'envers" (pointe en bas) pour que le flocon
            // se développe vers le haut et l'extérieur de manière classique.
             const p1_inv = {x: cx - size/2, y: cy + heightTri/3}; // Bas Gauche
             const p2_inv = {x: cx + size/2, y: cy + heightTri/3}; // Bas Droite
             const p3_inv = {x: cx, y: cy - 2*heightTri/3};       // Haut Pointe

            // On génère les points pour chaque côté dans le sens anti-horaire
            const side1 = getKochPoints(p1_inv, p2_inv, iter);
            const side2 = getKochPoints(p2_inv, p3_inv, iter);
            const side3 = getKochPoints(p3_inv, p1_inv, iter);

            const allPoints = [...side1, ...side2, ...side3];

            kCtx.beginPath();
            kCtx.strokeStyle = "#4cc9f0";
            kCtx.lineWidth = 1.5;
            kCtx.moveTo(allPoints[0].x, allPoints[0].y);
            for(let p of allPoints) kCtx.lineTo(p.x, p.y);
            kCtx.closePath();
            kCtx.stroke();

            // Stats
            // L_0 est normalisé à 100 unités arbitraires
            const theoreticalLen = 100 * Math.pow(4/3, iter);
            const numSeg = 3 * Math.pow(4, iter);
            document.getElementById('kochSegmentsDisplay').textContent = new Intl.NumberFormat().format(numSeg);
            document.getElementById('kochLengthDisplay').textContent = theoreticalLen.toFixed(1) + " u";
        }
        kSlider.addEventListener('input', drawKoch);
        drawKoch();


        /* =========================================
           3. L'ÎLE ALÉATOIRE & MESURE
           ========================================= */
        const iCanvas = document.getElementById('islandCanvas');
        const iCtx = iCanvas.getContext('2d');
        const iSlider = document.getElementById('islandRuler');
        let islandPoints = [];

        function generateBetterIsland() {
            islandPoints = [];
            const w = iCanvas.width;
            const h = iCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            // Rayon de base responsive
            const baseRadius = Math.min(w, h) * 0.25;
            // Amplitude du bruit proportionnelle au rayon
            const noiseAmp = baseRadius * 0.6; 
            const numPoints = 1200; 
            
            const seeds = [Math.random(), Math.random(), Math.random(), Math.random()];
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (Math.PI * 2 * i) / numPoints;
                // Génération fractale "noise"
                let noise = Math.sin(angle * 3 + seeds[0]) * noiseAmp +
                            Math.sin(angle * 10 + seeds[1]) * (noiseAmp*0.5) +
                            Math.sin(angle * 25 + seeds[2]) * (noiseAmp*0.25) +
                            Math.sin(angle * 60 + seeds[3]) * (noiseAmp*0.1);

                const r = baseRadius + noise;
                islandPoints.push({x: centerX + r * Math.cos(angle), y: centerY + r * Math.sin(angle)});
            }
        }

        // Fonction générique de mesure (compas)
        function measurePoly(points, rulerLen, ctx, w, h, scale=1, unit="px", filled=false) {
            if(points.length < 2) return;
            
            ctx.clearRect(0,0,w,h);

            // 1. Dessin de la forme réelle
            ctx.beginPath();
            if(filled) {
                ctx.fillStyle = "#1e2a38"; // Remplissage léger carte
            }
            ctx.strokeStyle = "#4895ef"; 
            ctx.lineWidth = 1.5;
            
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            if(filled) ctx.fill();
            ctx.stroke();

            // 2. Mesure au compas
            let mPoints = [points[0]];
            let currIdx = 0;
            let totalDist = 0;

            while(true) {
                let found = false;
                // Recherche du prochain point à distance 'rulerLen'
                for(let i = currIdx + 1; i < points.length; i++) {
                    let d = dist(points[currIdx], points[i]);
                    if (d >= rulerLen) {
                        totalDist += d;
                        mPoints.push(points[i]);
                        currIdx = i;
                        found = true;
                        break;
                    }
                }
                
                if(!found) {
                    // Tentative de fermeture de la boucle
                    let dFinal = dist(points[currIdx], points[0]);
                    // On ferme seulement si la distance restante est significative pour éviter de fermer trop tôt sur des formes concaves
                    if(dFinal >= rulerLen * 0.5 || mPoints.length > 3) { 
                        totalDist += dFinal;
                        mPoints.push(points[0]);
                    }
                    break;
                }
            }

            // 3. Dessin de la mesure
            ctx.beginPath();
            ctx.strokeStyle = "#f72585";
            ctx.lineWidth = 2.5;
            ctx.moveTo(mPoints[0].x, mPoints[0].y);
            for(let p of mPoints) {
                ctx.lineTo(p.x, p.y);
            }
             ctx.stroke();
             
             // Dessiner les points par dessus
            for(let p of mPoints) {
                ctx.beginPath();
                ctx.fillStyle = "#f72585";
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
            }

            return Math.round(totalDist * scale) + " " + unit;
        }

        function runIslandMeasurement() {
            const val = parseInt(iSlider.value);
            document.getElementById('islandRulerVal').textContent = val;
            const res = measurePoly(islandPoints, val, iCtx, iCanvas.width, iCanvas.height);
            document.getElementById('islandLengthDisplay').textContent = res;
        }

        iSlider.addEventListener('input', runIslandMeasurement);
        document.getElementById('newIslandBtn').addEventListener('click', () => {
            generateBetterIsland();
            runIslandMeasurement();
        });
        generateBetterIsland();
        runIslandMeasurement();


        /* =========================================
           4. LA GRANDE BRETAGNE (Tracé manuel & Responsive)
           ========================================= */
        const gCanvas = document.getElementById('gbCanvas');
        const gCtx = gCanvas.getContext('2d');
        const gSlider = document.getElementById('gbRuler');

        // Polygone simplifié manuel (Coordonnées normalisées 0-100)
        const gbShapeNormalized = [
            {x:30,y:85},{x:40,y:87},{x:50,y:85},{x:60,y:82},{x:75,y:80},{x:85,y:78}, 
            {x:88,y:75},{x:90,y:70},{x:88,y:65},{x:85,y:62}, 
            {x:82,y:55},{x:80,y:50},{x:78,y:40},{x:75,y:30}, 
            {x:70,y:20},{x:65,y:10},{x:55,y:5},{x:45,y:5},{x:40,y:10}, 
            {x:35,y:20},{x:30,y:30},{x:35,y:35}, 
            {x:30,y:40},{x:35,y:45},{x:40,y:48}, 
            {x:35,y:50},{x:30,y:55},{x:25,y:60},{x:20,y:58},{x:15,y:62},{x:20,y:68}, 
            {x:35,y:65},{x:40,y:70},{x:35,y:75},{x:30,y:80} 
        ];

        let gbPoints = [];

        // Fonction pour générer les points de la GB à la bonne échelle selon la taille du canvas
        function generateGBPoints() {
            gbPoints = [];
            const w = gCanvas.width;
            const h = gCanvas.height;

            // On veut que la forme occupe environ 60% de la largeur du canvas
            const intendedWidth = w * 0.6;
            // La forme normalisée fait environ 75 unités de large (90-15)
            const scaleFactor = intendedWidth / 75;

            const scaleX = scaleFactor;
            const scaleY = scaleFactor;
            // Centrage
            // Le centre de la forme normalisée est approx à (55, 45)
            const offsetX = w/2 - (55 * scaleX);
            const offsetY = h/2 - (45 * scaleY);

            for(let i=0; i<gbShapeNormalized.length; i++) {
                const p1 = gbShapeNormalized[i];
                const p2 = gbShapeNormalized[(i+1)%gbShapeNormalized.length];
                
                // Interpolation pour densifier le tracé (nécessaire pour la mesure)
                const steps = 20; 
                for(let j=0; j<steps; j++) {
                    const t = j/steps;
                    const nx = p1.x + (p2.x - p1.x)*t;
                    const ny = p1.y + (p2.y - p1.y)*t;
                    
                    gbPoints.push({
                        x: nx * scaleX + offsetX, 
                        y: ny * scaleY + offsetY
                    });
                }
            }
        }

        function runGBMeasurement() {
            // Si les points n'existent pas encore (premier chargement), on les génère
            if(gbPoints.length === 0) generateGBPoints();

            const rulerPx = parseInt(gSlider.value);
            document.getElementById('gbRulerVal').textContent = rulerPx;
            
            // Facteur d'échelle arbitraire pour l'affichage en "km"
            // Plus le canvas est grand, plus le facteur doit être petit pour garder des valeurs cohérentes
            const kmScaleFactor = 2000 / gCanvas.width; 
            
            const res = measurePoly(gbPoints, rulerPx, gCtx, gCanvas.width, gCanvas.height, kmScaleFactor, "km", true);
            document.getElementById('gbLengthDisplay').textContent = res;
        }

        gSlider.addEventListener('input', runGBMeasurement);
        
        // Initialisation différée pour assurer que le canvas a sa taille finale
        setTimeout(() => {
             generateGBPoints();
             runGBMeasurement();
        }, 200);


        /* =========================================
           GESTION DU REDIMENSIONNEMENT (Mobile)
           ========================================= */
        // Quand la fenêtre change de taille, on redessine tout pour s'adapter
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // On relance les fonctions de dessin principales
                drawSegment();
                drawKoch();
                // Pour l'île et la GB, il faut régénérer les points de base car l'échelle change
                generateBetterIsland();
                runIslandMeasurement();
                generateGBPoints();
                runGBMeasurement();
            }, 250); // Petit délai pour ne pas surcharger pendant le redimensionnement
        });

    </script>
</body>
</html>
