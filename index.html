<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Paradoxe du Littoral - Laboratoire Interactif</title>
    <style>
        /* --- STYLE THEME SOMBRE (CSS) --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e24;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0; /* Bleu cyan */
            --measure-color: #f72585; /* Rose néon */
            --coast-color: #4895ef; /* Bleu pour la côte */
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            line-height: 1.6;
        }

        h1 { margin: 40px 0; text-align: center; text-transform: uppercase; letter-spacing: 2px; color: var(--accent-color); }
        h2 { border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px; color: #fff; }
        p { color: #aaa; margin-bottom: 20px; }

        .section-container {
            background: var(--container-bg);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 800px;
            width: 100%;
            margin-bottom: 50px;
            border: 1px solid #333;
        }

        canvas {
            border-radius: 8px;
            background-color: #0a0a0f;
            width: 100%;
            height: auto; /* Responsive */
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            margin-bottom: 15px;
        }

        .controls {
            background-color: rgba(255,255,255,0.03);
            padding: 20px;
            border-radius: 8px;
        }

        .slider-header {
            display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold; color: var(--accent-color);
        }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--accent-color); margin-bottom: 15px;
        }

        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 6px; text-align: center; border: 1px solid #444;
        }

        .stat-value { font-size: 1.4em; font-weight: bold; color: #fff; }
        .stat-value.highlight { color: var(--measure-color); }
        .stat-label { font-size: 0.75em; color: #777; text-transform: uppercase; margin-top: 5px; }

        button {
            background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);
            padding: 8px 16px; border-radius: 4px; cursor: pointer; transition: 0.3s;
        }
        button:hover { background: var(--accent-color); color: #000; }

    </style>
</head>
<body>

    <h1>Laboratoire du Paradoxe du Littoral</h1>

    <div class="section-container">
        <h2>1. La Transformation : Le Segment de Koch</h2>
        <p>Avant de voir le flocon entier, regardons comment un simple segment de droite se transforme. Chaque segment est divisé en trois, et le tiers central est remplacé par un triangle. Augmentez les itérations pour voir la courbe se fracturer.</p>
        
        <canvas id="segmentCanvas" width="800" height="300"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="segIterVal">0</span>
            </div>
            <input type="range" id="segmentIterations" min="0" max="6" value="0" step="1">
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="segCountDisplay">1</div>
                    <div class="stat-label">Nombre de Segments</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value highlight" id="segLengthDisplay">100%</div>
                    <div class="stat-label">Longueur relative</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>2. L'Infini Borné : Le Flocon de Koch</h2>
        <p>En appliquant cette transformation sur les trois côtés d'un triangle, on obtient le Flocon. Notez que l'aire reste finie (le flocon tient dans l'écran), mais son périmètre tend vers l'infini.</p>
        
        <canvas id="kochCanvas" width="600" height="500"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="kochIterVal">0</span>
            </div>
            <input type="range" id="kochIterations" min="0" max="5" value="0" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="kochSegmentsDisplay">3</div>
                    <div class="stat-label">Nombre de segments</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value highlight" id="kochLengthDisplay">100 u</div>
                    <div class="stat-label">Périmètre Théorique</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>3. La Simulation : L'Île Aléatoire</h2>
        <p>Ici, nous mesurons une côte "fractale" générée aléatoirement. Utilisez le curseur pour changer la taille de votre "règle" (le pas de mesure &epsilon;). Observez la courbe rouge (votre mesure) se détacher de la côte bleue (le réel).</p>
        
        <canvas id="islandCanvas" width="600" height="400"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="islandRulerVal">80</span> px</span>
            </div>
            <input type="range" id="islandRuler" min="5" max="150" value="80" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight" id="islandLengthDisplay">0 px</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box" style="display:flex; align-items:center; justify-content:center; gap:10px; font-size:0.9em;">
                    <button onclick="generateBetterIsland(); runIslandMeasurement();">Générer nouvelle île</button>
                </div>
            </div>
        </div>
    </div>


     <div class="section-container">
        <h2>4. Le Cas Réel : La Grande-Bretagne</h2>
        <p>Le paradoxe appliqué à une vraie carte. Même avec une forme définie, la longueur mesurée dépend entièrement de la précision de votre instrument.</p>
        
        <canvas id="gbCanvas" width="600" height="650"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="gbRulerVal">100</span> km (approx)</span>
            </div>
            <input type="range" id="gbRuler" min="15" max="200" value="100" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight" id="gbLengthDisplay">0 km</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box" style="display:flex; flex-direction:column; justify-content:center;">
                    <div style="font-size:0.8em; color:#888;">Note :</div>
                    <div style="font-size:0.8em; color:#666;">Les données sont simplifiées pour la fluidité de l'animation.</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        /* =========================================
           FONCTIONS UTILITAIRES (MATHS)
           ========================================= */
        function dist(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        /* Fonction récursive de Koch générique */
        function getKochPoints(p1, p2, iterations) {
            if (iterations === 0) return [p1, p2];

            const vX = p2.x - p1.x;
            const vY = p2.y - p1.y;
            
            // Les 3 points intermédiaires
            const pA = {x: p1.x + vX/3, y: p1.y + vY/3};
            const pB = {x: p1.x + 2*vX/3, y: p1.y + 2*vY/3};
            
            // Calcul de la pointe (triangle équilatéral)
            const sin60 = Math.sqrt(3)/2;
            const cos60 = 0.5;
            const pTip = {
                x: pA.x + (pB.x - pA.x) * cos60 - (pB.y - pA.y) * sin60,
                y: pA.y + (pB.x - pA.x) * sin60 + (pB.y - pA.y) * cos60
            };

            // Récursion
            const seg1 = getKochPoints(p1, pA, iterations - 1);
            const seg2 = getKochPoints(pA, pTip, iterations - 1);
            const seg3 = getKochPoints(pTip, pB, iterations - 1);
            const seg4 = getKochPoints(pB, p2, iterations - 1);

            // On fusionne en évitant les doublons de points de jonction
            return [...seg1, ...seg2.slice(1), ...seg3.slice(1), ...seg4.slice(1)];
        }


        /* =========================================
           1. LE SEGMENT DE KOCH (Simple Ligne)
           ========================================= */
        const sCanvas = document.getElementById('segmentCanvas');
        const sCtx = sCanvas.getContext('2d');
        const sSlider = document.getElementById('segmentIterations');
        
        function drawSegment() {
            const iter = parseInt(sSlider.value);
            document.getElementById('segIterVal').textContent = iter;
            
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
            
            // Définition de la ligne de base (centrée)
            const start = {x: 50, y: 200};
            const end = {x: 750, y: 200};
            
            const points = getKochPoints(start, end, iter);

            // Dessin
            sCtx.beginPath();
            sCtx.strokeStyle = "#4cc9f0";
            sCtx.lineWidth = 2;
            sCtx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) sCtx.lineTo(points[i].x, points[i].y);
            sCtx.stroke();

            // Stats
            const numSeg = Math.pow(4, iter);
            const lenRatio = Math.pow(4/3, iter) * 100;
            document.getElementById('segCountDisplay').textContent = new Intl.NumberFormat().format(numSeg);
            document.getElementById('segLengthDisplay').textContent = lenRatio.toFixed(0) + "%";
        }
        sSlider.addEventListener('input', drawSegment);
        drawSegment();


        /* =========================================
           2. LE FLOCON DE KOCH (Triangle)
           ========================================= */
        const kCanvas = document.getElementById('kochCanvas');
        const kCtx = kCanvas.getContext('2d');
        const kSlider = document.getElementById('kochIterations');
        
        function drawKoch() {
            const iter = parseInt(kSlider.value);
            document.getElementById('kochIterVal').textContent = iter;
            kCtx.clearRect(0,0, kCanvas.width, kCanvas.height);

            // Triangle initial (réduit et centré pour ne pas dépasser)
            // Centre canvas: 300, 250. Taille base approx 300.
            const size = 300;
            const h = size * Math.sqrt(3)/2;
            const cx = 300;
            const cy = 280; // Un peu plus bas car ça grandit vers le haut

            const p1 = {x: cx - size/2, y: cy + h/3};
            const p2 = {x: cx + size/2, y: cy + h/3};
            const p3 = {x: cx, y: cy - 2*h/3};

            // On génère les points pour chaque côté
            const side1 = getKochPoints(p1, p3, iter);
            const side2 = getKochPoints(p3, p2, iter);
            const side3 = getKochPoints(p2, p1, iter); // Attention à l'ordre pour fermer

            const allPoints = [...side1, ...side2, ...side3];

            kCtx.beginPath();
            kCtx.strokeStyle = "#4cc9f0";
            kCtx.lineWidth = 1.5;
            kCtx.moveTo(allPoints[0].x, allPoints[0].y);
            for(let p of allPoints) kCtx.lineTo(p.x, p.y);
            kCtx.closePath();
            kCtx.stroke();

            // Stats
            const theoreticalLen = 100 * Math.pow(4/3, iter);
            const numSeg = 3 * Math.pow(4, iter);
            document.getElementById('kochSegmentsDisplay').textContent = new Intl.NumberFormat().format(numSeg);
            document.getElementById('kochLengthDisplay').textContent = theoreticalLen.toFixed(1) + " u";
        }
        kSlider.addEventListener('input', drawKoch);
        drawKoch();


        /* =========================================
           3. L'ÎLE ALÉATOIRE & MESURE
           ========================================= */
        const iCanvas = document.getElementById('islandCanvas');
        const iCtx = iCanvas.getContext('2d');
        const iSlider = document.getElementById('islandRuler');
        let islandPoints = [];

        function generateBetterIsland() {
            islandPoints = [];
            const centerX = iCanvas.width / 2;
            const centerY = iCanvas.height / 2;
            const baseRadius = 120;
            const numPoints = 1200; 
            
            const seeds = [Math.random(), Math.random(), Math.random(), Math.random()];
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (Math.PI * 2 * i) / numPoints;
                // Génération fractale "noise"
                let noise = Math.sin(angle * 3 + seeds[0]) * 30 +
                            Math.sin(angle * 10 + seeds[1]) * 15 +
                            Math.sin(angle * 25 + seeds[2]) * 8 +
                            Math.sin(angle * 60 + seeds[3]) * 3;

                const r = baseRadius + noise;
                islandPoints.push({x: centerX + r * Math.cos(angle), y: centerY + r * Math.sin(angle)});
            }
        }

        // Fonction générique de mesure (compas)
        function measurePoly(points, rulerLen, ctx, w, h, scale=1, unit="px", filled=false) {
            if(points.length < 2) return;
            
            ctx.clearRect(0,0,w,h);

            // 1. Dessin de la forme réelle
            ctx.beginPath();
            if(filled) {
                ctx.fillStyle = "#1e2a38"; // Remplissage léger carte
            }
            ctx.strokeStyle = "#4895ef"; 
            ctx.lineWidth = 1;
            
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            if(filled) ctx.fill();
            ctx.stroke();

            // 2. Mesure au compas
            let mPoints = [points[0]];
            let currIdx = 0;
            let totalDist = 0;

            while(true) {
                let found = false;
                // Recherche du prochain point à distance 'rulerLen'
                for(let i = currIdx + 1; i < points.length; i++) {
                    let d = dist(points[currIdx], points[i]);
                    if (d >= rulerLen) {
                        totalDist += d;
                        mPoints.push(points[i]);
                        currIdx = i;
                        found = true;
                        break;
                    }
                }
                
                if(!found) {
                    // Fermeture
                    let dFinal = dist(points[currIdx], points[0]);
                    if(dFinal > rulerLen * 0.5) { // On ferme si c'est significatif
                        totalDist += dFinal;
                        mPoints.push(points[0]);
                    }
                    break;
                }
            }

            // 3. Dessin de la mesure
            ctx.beginPath();
            ctx.strokeStyle = "#f72585";
            ctx.lineWidth = 2;
            ctx.moveTo(mPoints[0].x, mPoints[0].y);
            for(let p of mPoints) {
                ctx.lineTo(p.x, p.y);
                // Petit point
                ctx.fillStyle = "#f72585";
                ctx.fillRect(p.x-2, p.y-2, 4, 4);
            }
            ctx.stroke();

            return Math.round(totalDist * scale) + " " + unit;
        }

        function runIslandMeasurement() {
            const val = parseInt(iSlider.value);
            document.getElementById('islandRulerVal').textContent = val;
            const res = measurePoly(islandPoints, val, iCtx, iCanvas.width, iCanvas.height);
            document.getElementById('islandLengthDisplay').textContent = res;
        }

        iSlider.addEventListener('input', runIslandMeasurement);
        generateBetterIsland();
        runIslandMeasurement();


        /* =========================================
           4. LA GRANDE BRETAGNE (Tracé manuel)
           ========================================= */
        const gCanvas = document.getElementById('gbCanvas');
        const gCtx = gCanvas.getContext('2d');
        const gSlider = document.getElementById('gbRuler');

        // Polygone simplifié manuel pour ressembler VRAIMENT à la GB
        // Coordonnées normalisées (0-100)
        const gbShape = [
            {x:30,y:85},{x:40,y:87},{x:50,y:85},{x:60,y:82},{x:75,y:80},{x:85,y:78}, // Sud (Cornwall -> Kent)
            {x:88,y:75},{x:90,y:70},{x:88,y:65},{x:85,y:62}, // Est Anglia
            {x:82,y:55},{x:80,y:50},{x:78,y:40},{x:75,y:30}, // Côte Est
            {x:70,y:20},{x:65,y:10},{x:55,y:5},{x:45,y:5},{x:40,y:10}, // Ecosse Nord
            {x:35,y:20},{x:30,y:30},{x:35,y:35}, // Ecosse Ouest
            {x:30,y:40},{x:35,y:45},{x:40,y:48}, // Frontière Ecosse/Ang
            {x:35,y:50},{x:30,y:55},{x:25,y:60},{x:20,y:58},{x:15,y:62},{x:20,y:68}, // Pays de Galles
            {x:35,y:65},{x:40,y:70},{x:35,y:75},{x:30,y:80} // Retour vers Cornwall
        ];

        // On va densifier les points par interpolation linéaire pour que la mesure fonctionne bien
        // Sinon le "saut" entre deux points du tracé est trop grand pour une petite règle
        let gbPoints = [];
        const scaleX = 5; 
        const scaleY = 5;
        const offsetX = 50;
        const offsetY = 50;

        for(let i=0; i<gbShape.length; i++) {
            const p1 = gbShape[i];
            const p2 = gbShape[(i+1)%gbShape.length];
            
            // Nombre de sous-points à ajouter entre p1 et p2
            const steps = 15; 
            for(let j=0; j<steps; j++) {
                const t = j/steps;
                const nx = p1.x + (p2.x - p1.x)*t;
                const ny = p1.y + (p2.y - p1.y)*t;
                
                // Mise à l'échelle pour le canvas 600x650
                gbPoints.push({
                    x: nx * scaleX + offsetX, 
                    y: ny * scaleY + offsetY
                });
            }
        }

        function runGBMeasurement() {
            const rulerPx = parseInt(gSlider.value);
            document.getElementById('gbRulerVal').textContent = rulerPx;
            // 1 pixel = 3km approx pour cette échelle
            const res = measurePoly(gbPoints, rulerPx, gCtx, gCanvas.width, gCanvas.height, 3.5, "km", true);
            document.getElementById('gbLengthDisplay').textContent = res;
        }

        gSlider.addEventListener('input', runGBMeasurement);
        setTimeout(runGBMeasurement, 100);

    </script>
</body>
</html>
