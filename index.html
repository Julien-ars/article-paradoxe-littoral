<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Paradoxe du Littoral - Laboratoire Interactif V10</title>
    <style>
        /* --- STYLE THEME SOMBRE (CSS) --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e24;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0; /* Bleu cyan */
            --measure-color: #f72585; /* Rose néon */
            --coast-color: #4895ef; /* Bleu pour la côte */
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            margin: 0;
            line-height: 1.6;
        }

        h1 {
            margin: 30px 0; text-align: center; text-transform: uppercase;
            letter-spacing: 2px; color: var(--accent-color); font-size: 1.8em;
        }
        h2 {
            border-bottom: 1px solid #333; padding-bottom: 10px;
            margin-bottom: 20px; color: #fff; font-size: 1.3em;
        }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.95em; }

        .section-container {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        canvas {
            border-radius: 8px;
            background-color: #0a0a0f;
            width: 100%;
            height: auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            margin-bottom: 15px;
            display: block;
        }

        .controls {
            background-color: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 8px;
        }

        .slider-header {
            display: flex; justify-content: space-between; margin-bottom: 10px;
            font-weight: bold; color: var(--accent-color); font-size: 0.9em;
        }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--accent-color); margin-bottom: 15px;
        }

        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
        }
        .stats.single { grid-template-columns: 1fr; }

        .stat-box {
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;
            text-align: center; border: 1px solid #444;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        .stat-value { font-size: 1.2em; font-weight: bold; color: #fff; }
        .stat-value.highlight-pink { color: var(--measure-color); }
        .stat-value.highlight-blue { color: var(--accent-color); }
        
        .stat-label { font-size: 0.7em; color: #777; text-transform: uppercase; margin-top: 5px; }

        .button-area {
            margin-top: 15px;
            text-align: center;
        }

        button {
            background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);
            padding: 10px 20px; border-radius: 4px; cursor: pointer; transition: 0.3s; width: 100%; font-weight: bold;
        }
        button:hover { background: var(--accent-color); color: #000; }

        @media (min-width: 600px) {
            body { padding: 30px; }
            .section-container { padding: 30px; }
            h1 { font-size: 2.2em; }
            .stat-value { font-size: 1.5em; }
            button { width: auto; }
        }

    </style>
</head>
<body>

    <h1>Laboratoire du Paradoxe du Littoral</h1>

    <div class="section-container">
        <h2>1. La Transformation : Le Segment de Koch</h2>
        <p>Chaque segment est divisé en trois, et le tiers central est remplacé par un triangle pointant vers l'extérieur. Augmentez les itérations pour voir la courbe se fracturer et sa longueur augmenter.</p>
        
        <canvas id="segmentCanvas" width="800" height="350"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="segIterVal">0</span>
            </div>
            <input type="range" id="segmentIterations" min="0" max="5" value="0" step="1">
            
            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="segCountDisplay">1</div>
                    <div class="stat-label">Nombre de Segments totaux</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>2. L'Infini Borné : La Construction en Couches</h2>
        <p>Voici la construction du flocon étape par étape. Chaque nouvelle itération ajoute une série de triangles sur les côtés existants. Les nouvelles formes sont affichées dans une couleur plus claire.</p>
        
        <canvas id="layeredCanvas" width="600" height="600"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Étape</label>
                <span id="layeredIterVal">0</span>
            </div>
            <input type="range" id="layeredIterations" min="0" max="4" value="0" step="1">

            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="layeredStats">Triangle Initial</div>
                    <div class="stat-label">Description</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>3. La Simulation : L'Île Aléatoire</h2>
        <p>Utilisez le curseur pour changer la taille de votre "règle" (le pas de mesure &epsilon;). Observez la courbe rouge (votre mesure) se détacher de la côte bleue (le réel) quand la règle est trop grande.</p>
        
        <canvas id="islandCanvas" width="600" height="450"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="islandRulerValHeader">80</span> px</span>
            </div>
            <input type="range" id="islandRuler" min="5" max="150" value="80" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="islandLengthDisplay">0 px</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="islandEpsilonDisplay">80 px</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
            <div class="button-area">
                <button id="newIslandBtn">Générer une nouvelle île</button>
            </div>
        </div>
    </div>


     <div class="section-container">
        <h2>4. Le Cas Réel : La Grande-Bretagne</h2>
        <p>Le paradoxe appliqué à une vraie carte réaliste. Plus la règle est petite, plus elle entre dans les fjords écossais et les baies galloises, augmentant considérablement le résultat final.</p>
        
        <canvas id="gbCanvas" width="600" height="650"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="gbRulerValHeader">100</span> km (approx)</span>
            </div>
            <input type="range" id="gbRuler" min="15" max="180" value="100" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="gbLengthDisplay">0 km</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="gbEpsilonDisplay">100 km</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        /* =========================================
           FONCTIONS UTILITAIRES
           ========================================= */
        function dist(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        /* =========================================
           1. LE SEGMENT DE KOCH
           ========================================= */
        const sCanvas = document.getElementById('segmentCanvas');
        const sCtx = sCanvas.getContext('2d');
        const sSlider = document.getElementById('segmentIterations');
        
        function getSegPointsUp(p1, p2, n) {
            if (n === 0) return [p1, p2];
            const vx = p2.x - p1.x, vy = p2.y - p1.y;
            const pA = {x: p1.x + vx/3, y: p1.y + vy/3};
            const pB = {x: p1.x + 2*vx/3, y: p1.y + 2*vy/3};
            // Rotation -60 deg
            const c = 0.5, s = -Math.sqrt(3)/2;
            const vBaseX = pB.x - pA.x, vBaseY = pB.y - pA.y;
            const tip = {
                x: pA.x + (vBaseX * c - vBaseY * s),
                y: pA.y + (vBaseX * s + vBaseY * c)
            };
            return [...getSegPointsUp(p1, pA, n-1), ...getSegPointsUp(pA, tip, n-1), ...getSegPointsUp(tip, pB, n-1), ...getSegPointsUp(pB, p2, n-1)];
        }

        function drawSegment() {
            const iter = parseInt(sSlider.value);
            document.getElementById('segIterVal').textContent = iter;
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
            const w = sCanvas.width, h = sCanvas.height;
            const start = {x: w * 0.1, y: h * 0.75}; 
            const end = {x: w * 0.9, y: h * 0.75};
            const points = getSegPointsUp(start, end, iter);
            sCtx.beginPath();
            sCtx.strokeStyle = "#4cc9f0";
            sCtx.lineWidth = 2;
            sCtx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) sCtx.lineTo(points[i].x, points[i].y);
            sCtx.stroke();
            const numSeg = Math.pow(4, iter);
            document.getElementById('segCountDisplay').textContent = new Intl.NumberFormat().format(numSeg);
        }
        sSlider.addEventListener('input', drawSegment);
        drawSegment();


        /* =========================================
           2. CONSTRUCTION EN COUCHES
           ========================================= */
        const lCanvas = document.getElementById('layeredCanvas');
        const lCtx = lCanvas.getContext('2d');
        const lSlider = document.getElementById('layeredIterations');
        const lStats = document.getElementById('layeredStats');

        function drawLayered() {
            const maxIter = parseInt(lSlider.value);
            document.getElementById('layeredIterVal').textContent = maxIter;
            lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);
            const w = lCanvas.width, h = lCanvas.height;
            const size = Math.min(w, h) * 0.55; 
            const heightTri = size * Math.sqrt(3)/2;
            const cx = w / 2, cy = h / 2 + heightTri / 6; 
            
            const p1 = {x: cx - size/2, y: cy + heightTri/3};
            const p2 = {x: cx + size/2, y: cy + heightTri/3};
            const p3 = {x: cx, y: cy - 2*heightTri/3};

            let segments = [{a: p1, b: p2}, {a: p2, b: p3}, {a: p3, b: p1}];

            // Base
            lCtx.fillStyle = "#2c3e50";
            lCtx.beginPath();
            lCtx.moveTo(p1.x, p1.y); lCtx.lineTo(p2.x, p2.y); lCtx.lineTo(p3.x, p3.y);
            lCtx.closePath(); lCtx.fill();
            lCtx.strokeStyle = "#4cc9f0"; lCtx.lineWidth = 1; lCtx.stroke();

            for (let i = 0; i < maxIter; i++) {
                let nextSegments = [];
                const lightness = 40 + (i * 15);
                lCtx.fillStyle = `hsl(200, 70%, ${lightness}%)`; 
                lCtx.beginPath(); 
                for (let seg of segments) {
                    const u = seg.a, v = seg.b;
                    const vx = v.x - u.x, vy = v.y - u.y;
                    const pA = {x: u.x + vx/3, y: u.y + vy/3};
                    const pB = {x: u.x + 2*vx/3, y: u.y + 2*vy/3};
                    const c = 0.5, s = Math.sqrt(3)/2; 
                    const tipX = pA.x + (pB.x - pA.x)*c - (pB.y - pA.y)*s;
                    const tipY = pA.y + (pB.x - pA.x)*s + (pB.y - pA.y)*c;
                    const pTip = {x: tipX, y: tipY};
                    lCtx.moveTo(pA.x, pA.y); lCtx.lineTo(pB.x, pB.y); lCtx.lineTo(pTip.x, pTip.y); lCtx.lineTo(pA.x, pA.y);
                    nextSegments.push({a: u, b: pA}); nextSegments.push({a: pA, b: pTip});
                    nextSegments.push({a: pTip, b: pB}); nextSegments.push({a: pB, b: v});
                }
                lCtx.fill(); lCtx.stroke();
                segments = nextSegments;
            }

            let desc = "";
            if(maxIter === 0) desc = "Triangle Initial";
            else if(maxIter === 1) desc = "Étoile de David (6 branches)";
            else desc = `Itération ${maxIter} : ${segments.length/4} pointes ajoutées`;
            lStats.textContent = desc;
        }
        lSlider.addEventListener('input', drawLayered);
        drawLayered();


        /* =========================================
           3. L'ÎLE ALÉATOIRE
           ========================================= */
        const iCanvas = document.getElementById('islandCanvas');
        const iCtx = iCanvas.getContext('2d');
        const iSlider = document.getElementById('islandRuler');
        let islandPoints = [];

        function generateBetterIsland() {
            islandPoints = [];
            const w = iCanvas.width; const h = iCanvas.height;
            const cx = w / 2; const cy = h / 2;
            const baseRadius = Math.min(w, h) * 0.30; 
            
            const layers = [];
            const numLayers = 6;
            for(let j=0; j<numLayers; j++) {
                layers.push({
                    freq: 3 + Math.random() * 8 * (j+1),
                    amp: (baseRadius * 0.4) / (j + 1.2),
                    phase: Math.random() * Math.PI * 2
                });
            }

            const steps = 1500;
            for (let i = 0; i < steps; i++) {
                const angle = (Math.PI * 2 * i) / steps;
                let noise = 0;
                for(let l of layers) noise += Math.sin(angle * l.freq + l.phase) * l.amp;
                noise += (Math.random() - 0.5) * 5;
                let r = baseRadius + noise;
                if (r < baseRadius * 0.2) r = baseRadius * 0.2; 
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                islandPoints.push({x, y});
            }
        }

        function measurePoly(points, rulerLen, ctx, w, h, scale=1, unit="px", filled=false) {
            if(points.length < 2) return;
            
            // DESSIN DU POLYGONE
            ctx.clearRect(0,0,w,h);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.closePath();

            if(filled) {
                // Motif isométrique
                const patternCanvas = document.createElement('canvas');
                const patternCtx = patternCanvas.getContext('2d');
                const size = 20; 
                patternCanvas.width = size;
                patternCanvas.height = size * Math.sqrt(3);

                patternCtx.strokeStyle = 'rgba(255,255,255,0.08)'; 
                patternCtx.lineWidth = 1;
                patternCtx.beginPath();
                patternCtx.moveTo(size / 2, 0); patternCtx.lineTo(size / 2, patternCanvas.height);
                patternCtx.moveTo(0, size * Math.sqrt(3) / 4); patternCtx.lineTo(size, size * Math.sqrt(3) * 3 / 4);
                patternCtx.moveTo(size, size * Math.sqrt(3) / 4); patternCtx.lineTo(0, size * Math.sqrt(3) * 3 / 4);
                patternCtx.stroke();

                const pattern = ctx.createPattern(patternCanvas, 'repeat');
                ctx.fillStyle = pattern;
                ctx.fill();
                // Fond sombre léger par dessus le pattern
                ctx.fillStyle = "rgba(72, 149, 239, 0.15)";
                ctx.fill();
            } else {
                 ctx.fillStyle = "#1e2a38";
                 ctx.fill();
            }
            
            ctx.strokeStyle = "#4895ef"; ctx.lineWidth = 1.5;
            ctx.stroke();

            // ALGORITHME DE MESURE (Compas)
            let mPoints = [points[0]];
            let currIdx = 0; let totalDist = 0;
            let maxSteps = 5000; 
            let stepsCount = 0;

            while(stepsCount < maxSteps) {
                stepsCount++;
                let found = false;
                for(let i = currIdx + 1; i < points.length; i++) {
                    let d = dist(points[currIdx], points[i]);
                    if (d >= rulerLen) {
                        totalDist += d; mPoints.push(points[i]);
                        currIdx = i; found = true; break;
                    }
                }
                if(!found) {
                    let dFinal = dist(points[currIdx], points[0]);
                    if(dFinal >= rulerLen * 0.5 || mPoints.length > 3) { 
                        totalDist += dFinal; mPoints.push(points[0]);
                    }
                    break;
                }
                if (dist(points[currIdx], points[0]) < rulerLen && mPoints.length > 5 && currIdx > points.length - 100) {
                      totalDist += dist(points[currIdx], points[0]);
                      mPoints.push(points[0]);
                      break;
                }
            }

            // Dessin mesure
            ctx.beginPath(); ctx.strokeStyle = "#f72585"; ctx.lineWidth = 2.5;
            ctx.moveTo(mPoints[0].x, mPoints[0].y);
            for(let p of mPoints) ctx.lineTo(p.x, p.y);
            ctx.stroke();
            
            for(let p of mPoints) {
                ctx.beginPath(); ctx.fillStyle = "#f72585";
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            }
            return Math.round(totalDist * scale) + " " + unit;
        }

        function runIslandMeasurement() {
            const val = parseInt(iSlider.value);
            document.getElementById('islandRulerValHeader').textContent = val;
            document.getElementById('islandEpsilonDisplay').textContent = val + " px";
            const res = measurePoly(islandPoints, val, iCtx, iCanvas.width, iCanvas.height, 1, "px", false);
            document.getElementById('islandLengthDisplay').textContent = res;
        }

        iSlider.addEventListener('input', runIslandMeasurement);
        document.getElementById('newIslandBtn').addEventListener('click', () => {
            generateBetterIsland();
            runIslandMeasurement();
        });
        generateBetterIsland();
        runIslandMeasurement();


        /* =========================================
           4. LA GRANDE BRETAGNE (Version Squelette + Fractal)
           ========================================= */
        const gCanvas = document.getElementById('gbCanvas');
        const gCtx = gCanvas.getContext('2d');
        const gSlider = document.getElementById('gbRuler');

        let gbPoints = [];

        // Fonction récursive pour ajouter du bruit fractal entre deux points
        function interpolateWithNoise(p1, p2, depth, displacement) {
            if (depth === 0) return [p1];
            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;
            const nx = -(p2.y - p1.y);
            const ny = (p2.x - p1.x);
            const len = Math.sqrt(nx*nx + ny*ny);
            
            // Ajout du bruit perpendiculaire
            const normX = (nx / len) * (Math.random() - 0.5) * displacement;
            const normY = (ny / len) * (Math.random() - 0.5) * displacement;
            
            const mid = {x: mx + normX, y: my + normY};
            return [...interpolateWithNoise(p1, mid, depth-1, displacement/2), ...interpolateWithNoise(mid, p2, depth-1, displacement/2)];
        }

        function generateGBPoints() {
            gbPoints = [];
            // "Squelette" de la GB normalisé (0 à 1)
            // Ce tracé définit la forme globale : Ecosse, Pays de Galles, Cornouailles, East Anglia
            const gbSkeleton = [
                {x:0.25, y:0.95}, {x:0.15, y:0.92}, {x:0.12, y:0.88}, // Cornouailles
                {x:0.22, y:0.84}, {x:0.32, y:0.80}, // Canal de Bristol
                {x:0.28, y:0.75}, {x:0.18, y:0.75}, {x:0.18, y:0.68}, {x:0.28, y:0.65}, // Pays de Galles
                {x:0.38, y:0.60}, {x:0.45, y:0.62}, // Liverpool / Manchester
                {x:0.42, y:0.55}, {x:0.35, y:0.52}, {x:0.30, y:0.45}, // Lake District
                {x:0.35, y:0.40}, {x:0.25, y:0.35}, // Solway Firth
                {x:0.22, y:0.25}, {x:0.18, y:0.20}, {x:0.25, y:0.15}, // Hébrides / Ouest Ecosse
                {x:0.35, y:0.08}, {x:0.50, y:0.03}, {x:0.65, y:0.05}, // Nord Ecosse (Thurso)
                {x:0.75, y:0.12}, {x:0.65, y:0.18}, {x:0.55, y:0.22}, // Moray Firth
                {x:0.75, y:0.25}, {x:0.72, y:0.32}, // Aberdeen
                {x:0.65, y:0.35}, {x:0.55, y:0.38}, {x:0.62, y:0.42}, // Firth of Forth (Edinburgh)
                {x:0.68, y:0.48}, {x:0.72, y:0.55}, // Newcastle
                {x:0.78, y:0.60}, {x:0.65, y:0.62}, {x:0.75, y:0.65}, // The Wash
                {x:0.88, y:0.68}, {x:0.92, y:0.75}, // Norfolk / East Anglia
                {x:0.85, y:0.82}, {x:0.75, y:0.82}, {x:0.82, y:0.85}, {x:0.90, y:0.86}, // Tamise / Kent
                {x:0.85, y:0.90}, {x:0.75, y:0.92}, {x:0.60, y:0.96}, {x:0.45, y:0.94} // Côte Sud
            ];

            const w = gCanvas.width;
            const h = gCanvas.height;
            // On garde une marge
            const scaleX = w * 0.75;
            const scaleY = h * 0.90;
            const offsetX = w * 0.05;
            const offsetY = h * 0.05;

            // On parcourt le squelette et on fractalise chaque segment
            for(let i=0; i<gbSkeleton.length; i++) {
                const p1 = gbSkeleton[i];
                const p2 = gbSkeleton[(i+1)%gbSkeleton.length]; // Boucler sur le premier
                
                // Coordonnées écran
                const sP1 = {x: p1.x * scaleX + offsetX, y: p1.y * scaleY + offsetY};
                const sP2 = {x: p2.x * scaleX + offsetX, y: p2.y * scaleY + offsetY};

                // On génère 5 niveaux de détails fractals entre chaque point du squelette
                // Cela crée des centaines de points pour simuler la côte réelle
                const segmentPoints = interpolateWithNoise(sP1, sP2, 5, 25);
                gbPoints.push(...segmentPoints);
            }
        }

        function runGBMeasurement() {
            if(gbPoints.length === 0) generateGBPoints();
            const rulerPx = parseInt(gSlider.value);
            document.getElementById('gbRulerValHeader').textContent = rulerPx;
            document.getElementById('gbEpsilonDisplay').textContent = rulerPx + " km";
            
            // Approx échelle : hauteur GB ~ 900km pour canvas height
            const kmScaleFactor = 900 / gCanvas.height; 
            
            // filled=true active le motif hachuré stylisé
            const res = measurePoly(gbPoints, rulerPx, gCtx, gCanvas.width, gCanvas.height, kmScaleFactor, "km", true);
            document.getElementById('gbLengthDisplay').textContent = res;
        }

        gSlider.addEventListener('input', runGBMeasurement);
        
        // Gestion du redimensionnement
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                drawSegment(); drawLayered();
                generateBetterIsland(); runIslandMeasurement();
                generateGBPoints(); runGBMeasurement();
            }, 250);
        });

        // Init
        setTimeout(() => { generateGBPoints(); runGBMeasurement(); }, 100);

    </script>
</body>
</html>

