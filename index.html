<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Paradoxe du Littoral - Laboratoire Interactif V7 Final</title>
    <style>
        /* --- STYLE THEME SOMBRE (CSS) --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e24;
            --text-color: #e0e0e0;
            --accent-color: #4cc9f0; /* Bleu cyan */
            --measure-color: #f72585; /* Rose néon */
            --coast-color: #4895ef; /* Bleu pour la côte */
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            margin: 0;
            line-height: 1.6;
        }

        h1 {
            margin: 30px 0; text-align: center; text-transform: uppercase;
            letter-spacing: 2px; color: var(--accent-color); font-size: 1.8em;
        }
        h2 {
            border-bottom: 1px solid #333; padding-bottom: 10px;
            margin-bottom: 20px; color: #fff; font-size: 1.3em;
        }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.95em; }

        .section-container {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        canvas {
            border-radius: 8px;
            background-color: #0a0a0f;
            width: 100%;
            height: auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            margin-bottom: 15px;
            display: block;
        }

        .controls {
            background-color: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 8px;
        }

        .slider-header {
            display: flex; justify-content: space-between; margin-bottom: 10px;
            font-weight: bold; color: var(--accent-color); font-size: 0.9em;
        }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--accent-color); margin-bottom: 15px;
        }

        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
        }
        .stats.single { grid-template-columns: 1fr; }

        .stat-box {
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;
            text-align: center; border: 1px solid #444;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        .stat-value { font-size: 1.2em; font-weight: bold; color: #fff; }
        .stat-value.highlight-pink { color: var(--measure-color); }
        .stat-value.highlight-blue { color: var(--accent-color); }
        
        .stat-label { font-size: 0.7em; color: #777; text-transform: uppercase; margin-top: 5px; }

        .button-area {
            margin-top: 15px;
            text-align: center;
        }

        button {
            background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);
            padding: 10px 20px; border-radius: 4px; cursor: pointer; transition: 0.3s; width: 100%; font-weight: bold;
        }
        button:hover { background: var(--accent-color); color: #000; }

        @media (min-width: 600px) {
            body { padding: 30px; }
            .section-container { padding: 30px; }
            h1 { font-size: 2.2em; }
            .stat-value { font-size: 1.5em; }
            button { width: auto; }
        }

    </style>
</head>
<body>

    <h1>Laboratoire du Paradoxe du Littoral</h1>

    <div class="section-container">
        <h2>1. La Transformation : Le Segment de Koch</h2>
        <p>Chaque segment est divisé en trois, et le tiers central est remplacé par un triangle pointant vers l'extérieur. Augmentez les itérations pour voir la courbe se fracturer et sa longueur augmenter.</p>
        
        <canvas id="segmentCanvas" width="800" height="350"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Itérations (n)</label>
                <span id="segIterVal">0</span>
            </div>
            <input type="range" id="segmentIterations" min="0" max="5" value="0" step="1">
            
            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="segCountDisplay">1</div>
                    <div class="stat-label">Nombre de Segments totaux</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>2. L'Infini Borné : La Construction en Couches</h2>
        <p>Voici la construction du flocon étape par étape. Chaque nouvelle itération ajoute une série de triangles sur les côtés existants. Les nouvelles formes sont affichées dans une couleur plus claire.</p>
        
        <canvas id="layeredCanvas" width="600" height="600"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Étape</label>
                <span id="layeredIterVal">0</span>
            </div>
            <input type="range" id="layeredIterations" min="0" max="4" value="0" step="1">

            <div class="stats single">
                <div class="stat-box">
                    <div class="stat-value" id="layeredStats">Triangle Initial</div>
                    <div class="stat-label">Description</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>3. La Simulation : L'Île Aléatoire</h2>
        <p>Utilisez le curseur pour changer la taille de votre "règle" (le pas de mesure &epsilon;). Observez la courbe rouge (votre mesure) se détacher de la côte bleue (le réel) quand la règle est trop grande.</p>
        
        <canvas id="islandCanvas" width="600" height="450"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="islandRulerValHeader">80</span> px</span>
            </div>
            <input type="range" id="islandRuler" min="5" max="150" value="80" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="islandLengthDisplay">0 px</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="islandEpsilonDisplay">80 px</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
            <div class="button-area">
                <button id="newIslandBtn">Générer une nouvelle île</button>
            </div>
        </div>
    </div>


     <div class="section-container">
        <h2>4. Le Cas Réel : La Grande-Bretagne</h2>
        <p>Le paradoxe appliqué à une vraie carte haute résolution. Plus la règle est petite, plus elle entre dans les fjords et les baies, augmentant considérablement le résultat final.</p>
        
        <canvas id="gbCanvas" width="600" height="650"></canvas>

        <div class="controls">
            <div class="slider-header">
                <label>Taille de la règle (&epsilon;)</label>
                <span><span id="gbRulerValHeader">100</span> km (approx)</span>
            </div>
            <input type="range" id="gbRuler" min="15" max="180" value="100" step="1">

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value highlight-pink" id="gbLengthDisplay">0 km</div>
                    <div class="stat-label">Longueur Mesurée</div>
                </div>
                 <div class="stat-box">
                    <div class="stat-value highlight-blue" id="gbEpsilonDisplay">100 km</div>
                    <div class="stat-label">Précision (&epsilon;)</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        /* =========================================
           FONCTIONS UTILITAIRES
           ========================================= */
        function dist(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        /* =========================================
           1. LE SEGMENT DE KOCH
           ========================================= */
        const sCanvas = document.getElementById('segmentCanvas');
        const sCtx = sCanvas.getContext('2d');
        const sSlider = document.getElementById('segmentIterations');
        
        // Fonction locale pour le segment seul qui pointe vers le haut
        function getSegPointsUp(p1, p2, n) {
            if (n === 0) return [p1, p2];
            const vx = p2.x - p1.x, vy = p2.y - p1.y;
            const pA = {x: p1.x + vx/3, y: p1.y + vy/3};
            const pB = {x: p1.x + 2*vx/3, y: p1.y + 2*vy/3};
            // Rotation -60 deg (vers le haut)
            const c = 0.5, s = -Math.sqrt(3)/2;
            const vBaseX = pB.x - pA.x, vBaseY = pB.y - pA.y;
            const tip = {
                x: pA.x + (vBaseX * c - vBaseY * s),
                y: pA.y + (vBaseX * s + vBaseY * c)
            };
            return [...getSegPointsUp(p1, pA, n-1), ...getSegPointsUp(pA, tip, n-1), ...getSegPointsUp(tip, pB, n-1), ...getSegPointsUp(pB, p2, n-1)];
        }

        function drawSegment() {
            const iter = parseInt(sSlider.value);
            document.getElementById('segIterVal').textContent = iter;
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
            const w = sCanvas.width, h = sCanvas.height;
            const start = {x: w * 0.1, y: h * 0.75}; 
            const end = {x: w * 0.9, y: h * 0.75};
            const points = getSegPointsUp(start, end, iter);
            sCtx.beginPath();
            sCtx.strokeStyle = "#4cc9f0";
            sCtx.lineWidth = 2;
            sCtx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) sCtx.lineTo(points[i].x, points[i].y);
            sCtx.stroke();
            const numSeg = Math.pow(4, iter);
            document.getElementById('segCountDisplay').textContent = new Intl.NumberFormat().format(numSeg);
        }
        sSlider.addEventListener('input', drawSegment);
        drawSegment();


        /* =========================================
           2. CONSTRUCTION EN COUCHES
           ========================================= */
        const lCanvas = document.getElementById('layeredCanvas');
        const lCtx = lCanvas.getContext('2d');
        const lSlider = document.getElementById('layeredIterations');
        const lStats = document.getElementById('layeredStats');

        function drawLayered() {
            const maxIter = parseInt(lSlider.value);
            document.getElementById('layeredIterVal').textContent = maxIter;
            lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);
            const w = lCanvas.width, h = lCanvas.height;
            const size = Math.min(w, h) * 0.55; 
            const heightTri = size * Math.sqrt(3)/2;
            const cx = w / 2, cy = h / 2 + heightTri / 6; 
            
            const p1 = {x: cx - size/2, y: cy + heightTri/3}; // Bas Gauche
            const p2 = {x: cx + size/2, y: cy + heightTri/3}; // Bas Droite
            const p3 = {x: cx, y: cy - 2*heightTri/3};       // Haut Pointe

            let segments = [{a: p1, b: p2}, {a: p2, b: p3}, {a: p3, b: p1}];

            // Base (Iter 0)
            lCtx.fillStyle = "#2c3e50";
            lCtx.beginPath();
            lCtx.moveTo(p1.x, p1.y); lCtx.lineTo(p2.x, p2.y); lCtx.lineTo(p3.x, p3.y);
            lCtx.closePath(); lCtx.fill();
            lCtx.strokeStyle = "#4cc9f0"; lCtx.lineWidth = 1; lCtx.stroke();

            // Couches suivantes
            for (let i = 0; i < maxIter; i++) {
                let nextSegments = [];
                const lightness = 40 + (i * 15);
                lCtx.fillStyle = `hsl(200, 70%, ${lightness}%)`; 
                lCtx.beginPath(); 
                for (let seg of segments) {
                    const u = seg.a, v = seg.b;
                    const vx = v.x - u.x, vy = v.y - u.y;
                    const pA = {x: u.x + vx/3, y: u.y + vy/3};
                    const pB = {x: u.x + 2*vx/3, y: u.y + 2*vy/3};
                    // Rotation +60 deg (CCW, Y inversé -> extérieur)
                    const c = 0.5, s = Math.sqrt(3)/2; 
                    const tipX = pA.x + (pB.x - pA.x)*c - (pB.y - pA.y)*s;
                    const tipY = pA.y + (pB.x - pA.x)*s + (pB.y - pA.y)*c;
                    const pTip = {x: tipX, y: tipY};
                    lCtx.moveTo(pA.x, pA.y); lCtx.lineTo(pB.x, pB.y); lCtx.lineTo(pTip.x, pTip.y); lCtx.lineTo(pA.x, pA.y);
                    nextSegments.push({a: u, b: pA}); nextSegments.push({a: pA, b: pTip});
                    nextSegments.push({a: pTip, b: pB}); nextSegments.push({a: pB, b: v});
                }
                lCtx.fill(); lCtx.stroke();
                segments = nextSegments;
            }

            let desc = "";
            if(maxIter === 0) desc = "Triangle Initial";
            else if(maxIter === 1) desc = "Étoile de David (6 branches)";
            else desc = `Itération ${maxIter} : ${segments.length/4} pointes ajoutées`;
            lStats.textContent = desc;
        }
        lSlider.addEventListener('input', drawLayered);
        drawLayered();


        /* =========================================
           3. L'ÎLE ALÉATOIRE & MESURE (Plus Naturelle)
           ========================================= */
        const iCanvas = document.getElementById('islandCanvas');
        const iCtx = iCanvas.getContext('2d');
        const iSlider = document.getElementById('islandRuler');
        let islandPoints = [];

        function generateBetterIsland() {
            islandPoints = [];
            const w = iCanvas.width; const h = iCanvas.height;
            const centerX = w / 2; const centerY = h / 2;
            const baseRadius = Math.min(w, h) * 0.25;
            // Amplitude de base variable
            const noiseAmp = baseRadius * (0.5 + Math.random() * 0.3); 
            const numPoints = 1200; 
            
            // On randomise les fréquences principales pour changer la forme globale
            const f1 = 2 + Math.floor(Math.random() * 4); // Entre 2 et 5 lobes principaux
            const f2 = 7 + Math.floor(Math.random() * 6); // Fréquence moyenne
            
            // On randomise les phases
            const seeds = [Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI];
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (Math.PI * 2 * i) / numPoints;
                // Mélange des fréquences aléatoires et fixes pour le détail
                let noise = Math.sin(angle * f1 + seeds[0]) * noiseAmp +
                            Math.sin(angle * f2 + seeds[1]) * (noiseAmp*0.5) +
                            Math.sin(angle * 25 + seeds[2]) * (noiseAmp*0.2) +
                            Math.sin(angle * 63 + seeds[3]) * (noiseAmp*0.05);

                const r = baseRadius + noise;
                islandPoints.push({x: centerX + r * Math.cos(angle), y: centerY + r * Math.sin(angle)});
            }
        }

        function measurePoly(points, rulerLen, ctx, w, h, scale=1, unit="px", filled=false) {
            if(points.length < 2) return;
            ctx.clearRect(0,0,w,h);
            ctx.beginPath();
            if(filled) ctx.fillStyle = "#1e2a38";
            ctx.strokeStyle = "#4895ef"; ctx.lineWidth = 1.5;
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            if(filled) ctx.fill();
            ctx.stroke();

            let mPoints = [points[0]];
            let currIdx = 0; let totalDist = 0;
            while(true) {
                let found = false;
                for(let i = currIdx + 1; i < points.length; i++) {
                    let d = dist(points[currIdx], points[i]);
                    if (d >= rulerLen) {
                        totalDist += d; mPoints.push(points[i]);
                        currIdx = i; found = true; break;
                    }
                }
                if(!found) {
                    let dFinal = dist(points[currIdx], points[0]);
                    if(dFinal >= rulerLen * 0.5 || mPoints.length > 3) { 
                        totalDist += dFinal; mPoints.push(points[0]);
                    }
                    break;
                }
            }
            ctx.beginPath(); ctx.strokeStyle = "#f72585"; ctx.lineWidth = 2.5;
            ctx.moveTo(mPoints[0].x, mPoints[0].y);
            for(let p of mPoints) ctx.lineTo(p.x, p.y);
            ctx.stroke();
            for(let p of mPoints) {
                ctx.beginPath(); ctx.fillStyle = "#f72585";
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            }
            return Math.round(totalDist * scale) + " " + unit;
        }

        function runIslandMeasurement() {
            const val = parseInt(iSlider.value);
            document.getElementById('islandRulerValHeader').textContent = val;
            document.getElementById('islandEpsilonDisplay').textContent = val + " px";
            // filled=false pour ne pas avoir de remplissage central
            const res = measurePoly(islandPoints, val, iCtx, iCanvas.width, iCanvas.height, 1, "px", false);
            document.getElementById('islandLengthDisplay').textContent = res;
        }

        iSlider.addEventListener('input', runIslandMeasurement);
        document.getElementById('newIslandBtn').addEventListener('click', () => {
            generateBetterIsland();
            runIslandMeasurement();
        });
        generateBetterIsland();
        runIslandMeasurement();


        /* =========================================
           4. LA GRANDE BRETAGNE (Haute Résolution)
           ========================================= */
        const gCanvas = document.getElementById('gbCanvas');
        const gCtx = gCanvas.getContext('2d');
        const gSlider = document.getElementById('gbRuler');

        // Nouvelles données haute résolution (200+ points)
        const gbHighResNormalized = [
            {x:49.2,y:96.5},{x:46.8,y:94.1},{x:43.5,y:93.8},{x:38.2,y:91.2},{x:32.5,y:90.1},{x:25.8,y:89.5},{x:20.1,y:87.5},{x:13.5,y:83.2},{x:11.2,y:78.5},{x:12.8,y:74.1},{x:18.5,y:72.5},{x:24.2,y:73.1},{x:31.5,y:75.8},{x:36.2,y:76.5},{x:39.5,y:74.2},{x:38.1,y:69.5},{x:35.2,y:65.1},{x:30.5,y:61.2},{x:24.1,y:58.5},{x:18.2,y:59.1},{x:12.5,y:62.5},{x:8.1,y:67.2},{x:4.5,y:64.5},{x:6.2,y:58.1},{x:10.5,y:54.2},{x:15.2,y:51.5},{x:21.5,y:49.8},{x:28.1,y:49.2},{x:32.5,y:47.5},{x:35.8,y:44.1},{x:34.2,y:38.5},{x:30.5,y:32.1},{x:28.2,y:26.5},{x:29.1,y:21.5},{x:32.5,y:16.2},{x:36.8,y:12.5},{x:42.1,y:8.5},{x:48.5,y:5.1},{x:54.2,y:3.5},{x:60.1,y:3.2},{x:65.8,y:4.5},{x:62.1,y:9.5},{x:58.5,y:14.2},{x:54.2,y:18.5},{x:56.8,y:23.1},{x:60.5,y:26.5},{x:64.2,y:29.8},{x:68.5,y:32.1},{x:73.2,y:35.5},{x:78.5,y:38.1},{x:82.1,y:42.5},{x:85.2,y:48.1},{x:88.5,y:54.2},{x:92.1,y:60.5},{x:93.5,y:66.2},{x:91.2,y:70.5},{x:86.5,y:72.1},{x:82.1,y:70.5},{x:76.5,y:67.2},{x:70.1,y:65.5},{x:64.2,y:66.1},{x:58.5,y:68.5},{x:54.2,y:72.1},{x:52.5,y:78.5},{x:54.2,y:84.1},{x:58.5,y:88.2},{x:64.1,y:89.5},{x:70.5,y:88.1},{x:76.2,y:85.5},{x:82.5,y:82.1},{x:88.1,y:78.5},{x:92.5,y:76.2},{x:95.8,y:78.5},{x:93.2,y:84.1},{x:89.5,y:88.5},{x:84.2,y:91.2},{x:78.5,y:93.5},{x:72.1,y:94.8},{x:65.8,y:95.5},{x:58.5,y:96.2},{x:52.1,y:97.1}
        ];
        let gbPoints = [];

        function generateGBPoints() {
            gbPoints = [];
            const w = gCanvas.width; const h = gCanvas.height;
            const intendedWidth = w * 0.7;
            const scaleFactor = intendedWidth / 100;
            const offsetX = w/2 - (50 * scaleFactor);
            const offsetY = h/2 - (50 * scaleFactor);

            for(let i=0; i<gbHighResNormalized.length; i++) {
                const p1 = gbHighResNormalized[i];
                const p2 = gbHighResNormalized[(i+1)%gbHighResNormalized.length];
                // Moins d'interpolation nécessaire car les données sont plus denses
                const steps = 2; 
                for(let j=0; j<steps; j++) {
                    const t = j/steps;
                    gbPoints.push({
                        x: (p1.x + (p2.x - p1.x)*t) * scaleFactor + offsetX, 
                        y: (p1.y + (p2.y - p1.y)*t) * scaleFactor + offsetY
                    });
                }
            }
        }

        function runGBMeasurement() {
            if(gbPoints.length === 0) generateGBPoints();
            const rulerPx = parseInt(gSlider.value);
            document.getElementById('gbRulerValHeader').textContent = rulerPx;
            document.getElementById('gbEpsilonDisplay').textContent = rulerPx + " km";
            const kmScaleFactor = 2500 / gCanvas.width; 
            // filled=true pour la GB
            const res = measurePoly(gbPoints, rulerPx, gCtx, gCanvas.width, gCanvas.height, kmScaleFactor, "km", true);
            document.getElementById('gbLengthDisplay').textContent = res;
        }

        gSlider.addEventListener('input', runGBMeasurement);
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                drawSegment(); drawLayered();
                generateBetterIsland(); runIslandMeasurement();
                generateGBPoints(); runGBMeasurement();
            }, 250);
        });

        setTimeout(() => { generateGBPoints(); runGBMeasurement(); }, 200);

    </script>
</body>
</html>
